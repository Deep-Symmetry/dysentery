= Track Metadata
James Elliott <james@deepsymmetry.org>
:icons: font
:experimental:

Thanks to https://github.com/EvanPurkhiser[@EvanPurkhiser], we finally
started making progress in retrieving metadata from CDJs, and then
some shared code from https://bitbucket.org/awwright/libpdjl[Austin
Wright] boosted our understanding considerably, and led to this
section.

== Connecting to the Database

The first step is to determine the port on which the player is
offering its remote database server. That can be determined by opening
a TCP connection to port 12523 on the player and sending it sending
a packet with the following content:

.DB Server query packet.
[bytefield]
----
(draw-column-headers)
(draw-related-boxes (concat [0 0 0 0x0f]
                            (map #(text % :hex) "RemoteDBServer")
                            [0]))
----

The player will send back a two-byte response, containing the high
byte of the port number followed by the low byte. So far, the response
from a CDJ has always indicated a port number of 1051, but using this
query to determine the port to use will protect you against any future
changes. The same query can also be sent to a laptop running rekordbox
to find the rekordbox database server port, which can also be queried
for metadata in the exact same way described below.

To find the metadata associated with a particular track, given its
rekordbox ID number, as well as the player and slot from which it was
loaded (all of which can be determined from a CDJ status packet
received by a virtual CDJ as described in TODO: _Section 4_), open a
TCP connection to the device from which the track was loaded, using
the port that it gave you in response to the DB Server query packet,
then send the following four packets. (You can also get metadata for
non-rekordbox tracks, even for CD Audio tracks being played in the CD
slot, using the variation described in TODO: _Section 6.6_.)

Once you have determined the database port, send it a setup packet
with the following content, and the server will send the same five
bytes back:

.Database connection setup packet.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field 1)
----

All further packets have a shared structure. They consist of lists of
type-tagged fields (a type byte, followed some number of value bytes,
although in the case of the variable-size types, the first four bytes
are a big-endian integer that specifies the length of the additional
value bytes that make up the field). So far, there are four known
field types, and it turns out that the packet we just saw is one of
them, it represents the number 1 as a 4-byte integer.

== Field Types

The first byte of a field identifies what type of field is coming. The
values `0f`, `10`, and `11` are followed by `1`, `2`, and `4` byte
fixed-length integer fields, while `14` and `26` introduce
variable-length fields, a binary blob and a UTF-16 big-endian string
respectively.

=== Number Fields

Number fields are indicated by an initial byte `0f`, `10`, or `11`
which is followed by big-endian integer value of length `1`, `2`, or
`4` bytes respectively, as shown below. So, as noted above, the
initial greeting packet sent to and received back from the database
server is a number field, four bytes long, representing the value 1.

.Number Field of length 1.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 2)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 1)
----

.Number Field of length 2.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 3)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 2)
----

.Number Field of length 4.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math))
----

=== Binary Fields

Variable-length binary (blob) fields are indicated by an initial byte
`14`, followed by a `4` byte big-endian integer which specifies the
length of the field payload. This length is followed by the specified
number of bytes (for example, an album art image, waveform or beat
grid):

.Binary (Blob) Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-field 0x14 (text "length" :math))
(draw-box "Binary Data" [{:span 11} :box-above])
(draw-gap)
(draw-bottom)
----

=== String Fields

Variable-length string fields are indicated by an initial byte `26`,
followed by a `4` byte big-endian integer which specifies the length
of the string, in two-byte UTF-16 big-endian characters. So the length
is folowed by 2 Ã— _length_ bytes containing the actual string
characters. The last character of the string is always `NUL`,
represented by `0000`:

.String Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-field 0x26 (text "length" :math))
(draw-box "UTF-16BE string" [{:span 11} :box-above])
(draw-gap)
(draw-bottom)
----


To be continued...

.Cue point response message.
[bytefield]
----
;; Figure 48
include::example$dbserver_shared.edn[]
include::example$cue_point_response.edn[]
----

include::partial$Footer.adoc[]
