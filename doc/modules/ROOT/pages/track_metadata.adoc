= Track Metadata
James Elliott <james@deepsymmetry.org>
:icons: font
:experimental:

Thanks to https://github.com/EvanPurkhiser[@EvanPurkhiser], we finally
started making progress in retrieving metadata from CDJs, and then
some shared code from https://bitbucket.org/awwright/libpdjl[Austin
Wright] boosted our understanding considerably, and led to this
section.

== Connecting to the Database

The first step is to determine the port on which the player is
offering its remote database server. That can be determined by opening
a TCP connection to port 12523 on the player and sending it sending
a packet with the following content:

.DB Server query packet.
[bytefield]
----
(draw-column-headers)
(draw-related-boxes (concat [0 0 0 0x0f]
                            (map #(text % :hex) "RemoteDBServer")
                            [0]))
----

The player will send back a two-byte response, containing the high
byte of the port number followed by the low byte. So far, the response
from a CDJ has always indicated a port number of 1051, but using this
query to determine the port to use will protect you against any future
changes. The same query can also be sent to a laptop running rekordbox
to find the rekordbox database server port, which can also be queried
for metadata in the exact same way described below.

To find the metadata associated with a particular track, given its
rekordbox ID number, as well as the player and slot from which it was
loaded (all of which can be determined from a CDJ status packet
received by a virtual CDJ as described in
<<vcdj#creating-vcdj,Creating a Virtual CDJ>>), open a TCP connection
to the device from which the track was loaded, using the port that it
gave you in response to the DB Server query packet, then send the
following four packets. (You can also get metadata for non-rekordbox
tracks, even for CD Audio tracks being played in the CD slot, using
the variation described in TODO: Section 6.6.)

Once you have determined the database port, send it a setup packet
with the following content, and the server will send the same five
bytes back:

.Database connection setup packet.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field 1)
----

All further packets have a shared structure. They consist of lists of
type-tagged fields (a type byte, followed some number of value bytes,
although in the case of the variable-size types, the first four bytes
are a big-endian integer that specifies the length of the additional
value bytes that make up the field). So far, there are four known
field types, and it turns out that the packet we just saw is one of
them, it represents the number 1 as a 4-byte integer.

== Field Types

The first byte of a field identifies what type of field is coming. The
values `0f`, `10`, and `11` are followed by `1`, `2`, and `4` byte
fixed-length integer fields, while `14` and `26` introduce
variable-length fields, a binary blob and a UTF-16 big-endian string
respectively.

=== Number Fields

Number fields are indicated by an initial byte{nbsp}``0f``, `10`, or
`11` which is followed by big-endian integer value of length `1`, `2`,
or `4` bytes respectively, as shown below. So, as noted above, the
initial greeting packet sent to and received back from the database
server is a number field, four bytes long, representing the value 1.

.Number Field of length 1.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 2)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 1)
----

.Number Field of length 2.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 3)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 2)
----

.Number Field of length 4.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math))
----

=== Binary Fields

Variable-length binary (blob) fields are indicated by an initial
byte{nbsp}``14``, followed by a `4` byte big-endian integer which
specifies the length of the field payload. This length is followed by
the specified number of bytes (for example, an album art image,
waveform or beat grid):

.Binary (Blob) Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-binary-field "Binary Data")
(draw-bottom)
----

=== String Fields

Variable-length string fields are indicated by an initial
byte{nbsp}``26``, followed by a `4` byte big-endian integer which
specifies the length of the string, in two-byte UTF-16 big-endian
characters. So the length is folowed by 2 × _length_ bytes containing
the actual string characters. The last character of the string is
always `NUL`, represented by `0000`:

.String Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-string-field "UTF-16BE string")
(draw-bottom)
----

[[messages]]
== Messages

Messages are introduced by a 4{nbsp}byte Number field containing a
“magic“ value (it is always `872349ae`). This is followed by another
4{nbsp}byte number field that contains a transaction ID (_TxID_),
which starts at 1 and is incremented for each query sent, and all
messages sent in response to that query will contain the same
transaction ID. This is followed by a 2{nbsp}byte number field
containing the message _type_, a 1{nbsp}byte number field (_n_)
containing the number of argument fields present in the message, and a
blob field containing a series of bytes which identify the types of
each argument field (shown as _t~1~_ through _t~12~_ below). This blob
is always twelve bytes long, regardless of how few arguments there are
(and presumably this means no message ever has more than twelve
arguments). Tag bytes past the actual argument count of the message
are set to 0.

This header is followed by the fields that make up the message
arguments, if any. In other words, the message body consists of
arguments identified by the header.

.Message structure showing header fields.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-number-field 0x872349ae 4 :bg-green)
(draw-number-field (text "TxID" :math) 4 :bg-yellow)
(draw-number-field (text "type" :math) 2 :bg-pink)
(draw-number-field (text "n" :math) 1 :bg-cyan)
(draw-box 0x14 [:bg-purple {:borders {:left   :border-unrelated
                                      :top    :border-unrelated
                                      :right  :border-related
                                      :bottom :border-related}}])

(draw-box (text "0000000c" :hex [[:plain {:font-weight "light" :font-size 16}] " (12)"])
          [{:span 4} [:bg-purple {:borders {:left   :border-related
                                            :top    :border-unrelated
                                            :right  :border-related
                                            :bottom :border-unrelated}}]])
(doseq [i (map inc (range 11))]
  (draw-box (text "t" :math [:sub i]) [:box-related :bg-purple]))
(draw-box (text "t" :math [:sub 12]) [:bg-purple {:borders {:left   :border-related
                                                  :top    :border-related
                                                  :right  :border-unrelated
                                                  :bottom :border-unrelated}}])
(draw-gap "Arguments")
(draw-bottom)
----

The argument type tags use different values than the field type tags
themselves, for some reason, and it is not clear why this redundant
information is necessary at all—but that is true a number of places in
the protocol as we have seen before and will see again. Here are the
known tag values and their meanings:

[[message-argument-tag-values]]
.Argument tag values.
[cols=">1m,<15"]
|===
|Tag |Meaning

|02 |A string in UTF-16 big-endian encoding, with trailing NUL (zero) character.
|03 |A binary blob.
|06 |A 4 byte big-endian integer.
|===

I am guessing that if we ever see them, a tag of `04` would represent
a 1{nbsp}byte integer, and `05` would represent a 2{nbsp}byte integer.
But so far no such messages have been seen.

Before you can send your first actual query, you need to send a
special message which seems to be necessary for establishing the
context for queries. It has a _type_ of `0000`, a special _TxID_ value
of `fffffffe`, and a single numeric argument, like this:

.Query context setup message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0 6)
(draw-number-field (text "D" :math [:sub "ours"]))
----

The value _D_ is, like in the other packets we have seen, a player
device number. In this case it is the device that is asking for
metadata information. It must be a valid player number between 1 and
4, and that player must actually be present on the network, must not
be the same player that you are contacting to request metadata from,
and must not be a player that has connected to that player via Link
and loaded a track from it. So the safest device number to use is the
device number you are using for your virtual CDJ, but since it must be
between 1 and 4, you can only do that if there are fewer than four
actual CDJs on the network.

The player will respond with a message of type `4000`, which is the
common “success” response when requested data is available. The
response message has two numeric arguments, the first of which is the
message type of the request we sent (which was `0000`), and the second
usually tells you the number of items that are available in response
to the query you made, but in this special setup query, it returns its
own player number:

[[query-context-setup-response]]
.Query context setup response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header "0 response" 6 6)
(draw-number-field 0)
(draw-number-field (text "D" :math [:sub "theirs"]))
----

[[track-metadata]]
== Rekordbox Track Metadata

To ask for metadata about a particular rekordbox track, send a packet
like this:

.Rekordbox track metadata request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2002 6 6)
(draw-dmst-field 1)
(draw-number-field (text "rekordbox" :math))
----

As described above, _TxID_ should be 1 for the first query packet you
send, 2 for the next, and so on.

The first argument of this message requires a little explanation: it
is sent as a four-byte number field, but each byte has a separate
meaning. _D_ should have the same value you used in your initial query
context setup packet, identifying the device that is asking the
question. The second byte is referred to as _M_, and seems to identify
the particular menu location on the CDJ where results are going to be
displayed. For this kind of metadata request it always has the value
`01`.

_S~r~_ is the slot in which the track being asked about can be found,
and has the same values used in CDJ status packets, as described in
the <<vcdj#slot-identifiers,CDJ status packet description>>.
Similarly, _T~r~_ identifies the type of track we want information
about; for rekordbox tracks this always has the value `01`.

This first argument format is used for many different requests about
tracks, so it is given the acronym _DMST_ in future discussion.

The second message argument, _rekordbox_, identifies the local
rekordbox database ID of the track being asked about, as found in the
<<vcdj#cdj-status-packet,CDJ status packet>>.

As suggested in the above description, track metadata requests are
built on the mechanism that is used to request and draw scrollable
menus on the CDJs, so the request is essentially interpreted as
setting up to draw the “menu” of information that is known about the
track. The player responds with a success indicator, saying it is
ready to send these “menu items” and reporting how many of them are
available:

.Track metadata available response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4000 6 6)
(draw-number-field 0x2002)
(draw-number-field 0xb)
----

We’ve seen this type of “data available” response already in the
<<query-context-setup-response,query context setup response>>, but
this one is a more typical example. As usual, _TxID_ matches the value
we sent in our request, and the first argument, with value `2002`,
reflects the _type_ field of our request. The second argument reports
that there are 11 (`0b`) entries of track metadata available to be
retrieved for the track we asked about, and that the player is ready
to send them to us.

If there was no track with ID _rekordbox_ in that media slot, the
second argument would have the value `ffffffff` to let us know. If we
messed up something else about the request, we will get a response
with a _type_ other than `4000`. See TODO: Section 6.16 for
instructions on how to explore these variations on your own.

But assuming everything went well, we can get the player to send us
all eleven of those metadata entries by telling it to render all of
the current menu, using a “render menu” request with _type_ `3000`
like this:

.Render Menu request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x3000 6 6 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field (text "offset" :math))
(draw-number-field (text "limit" :math))
(draw-number-field 0)
(draw-number-field (text "total" :math))
(draw-number-field 0)
----

As always, the value of _TxID_ should be one higher than the one you
sent in your setup packet, while the values of _D_, _S~r~_, and _T~r~_
should be identical to what you sent in it.

The request has six numeric arguments. At this point it is worth
talking a bit more about the byte after _D_ in the first argument.
This seems to specify the location of the menu being drawn, with the
value 1 meaning the main menu on the left-hand half of the CDJ
display, while 2 means the submenu (for example the info popup when it
is open) which overlays the right-hand half of the display. We don’t
yet know exactly what, if any, difference there is between the
response details when 2 is used instead of 1 here. And special data
requests use different values: for example, the track waveform
summary, which is drawn in a strip along the entire bottom of the
display, is requested with a menu location number of 8 in this second
byte.

As described above, _T~r~_ has the value 1 for rekordbox tracks.

The second argument, _offset_, specifies which menu entry is the first
one you want to see, and the third argument, _limit_, specifies how
many should be sent. In this case, since there are only 11 entries, we
can request them all at once, so we will set _offset_ to 0 and _limit_
to 11. But for large playlists, for example, you need to request
batches of entries that are smaller than the total available, or the
player will be unable to send them to you. We have not found what the
exact limit is, but getting 64 at a time seems to work on Nexus 2
players.

We don’t know the purpose of the fourth argument, but sending a value
of 0 works. The fifth argument, _total_, seems to usually contain the
total number of items reported in the intial menu response, but
sending a second copy of _limit_ here works too; it may not matter much.
And the sixth and final argument also has an unknown purpose, but 0
works.

So, for our metadata request, the packet we want to send in order to
get all the metadata will have the specific values shown here:

.Render track metadata request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x3000 6 6 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field 0)
(draw-number-field 0xb)
(draw-number-field 0)
(draw-number-field 0xb)
(draw-number-field 0)
----

This causes the player to send us 13 messages: The 11 metadata items
we requested are sent (with _type_ `4101`, <<menu-item-response,second
figure below>>), but they are preceded by a menu header message (with
_type_ `4001`, <<menu-header-response,first figure below>>), and
followed by a menu footer message (with _type_ `4201`,
<<menu-footer-response,third figure below>>). This wrapping happens
with all “render menu” requests, and the menu footer is an easy way to
know you are done, although you can also count the messages.

[[menu-header-response]]
.Menu header response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4001 6 6)
(draw-number-field 1)
(draw-number-field 0)
----

The menu item responses all have the same structure, and use all
twelve message argument slots, containing ten numbers and two strings,
although they generally don’t have meaningful values in all of the
slots. They have the general structure shown here, and the arguments
are listed in the Table <<menu-item-arguments,below>>:

[[menu-item-response]]
.Menu item response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4101 6 6 6 2 6 2 6 6 6 6 6 6)
(draw-gap "Arguments")
(draw-bottom)
----

[[menu-footer-response]]
.Menu footer response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4201)
----

[[menu-item-arguments]]
.Menu item arguments.
[cols=">1,^3,<12"]
|===
|Arg |Type |Meaning

|1 |number |Parent ID, such as an artist for a track item.
|2 |number |Main ID, such as _rekordbox_ for a track item.
|3 |number |Length in bytes of Label 1.
|4 |string |Label 1 (main text, such as the track title or artist name, as appropriate for the item type).
|5 |number |Length in bytes of Label 2.
|6 |string |Label 2 (secondary text, e.g. artist name for playlist entries, where Label 1 holds the title).
|7 |number |Type of this item (see TODO: Section 6.5).
|8 |number |Some sort of flags field, details still unclear.
|9 |number |Holds _artwork_ ID when type is Track Title.
|10 |number |Playlist position when relevant, e.g. when listing a playlist.
|11 |number |Unknown.
|12 |number |Unknown.
|===

=== Track Metadata Item 1: Title

The first item returned after the menu header is the track title, so
argument 7 has the value `04`. Argument 1, which may always be some
kind of parent ID, holds the artist ID associated with the track. The
second argument seems to always be the main ID, and for this response
it holds the _rekordbox_ ID of the track. Argument 4 holds the track
title text, and argument 9 holds the album _artwork_ ID if any is
available for the track. This ID can be used to retrieve the actual
album art image as described in TODO: Section 6.7.

=== Track Metadata Item 2: Artist

The second item contains artist information, so argument 7 has the
value `07`. Argument 2 holds the artist ID, and argument 4 contains
the text of the artist name.

=== Track Metadata Item 3: Album Title

The third item contains album title information, so argument 7 has the
value `02`. Argument 4 contains the text of the album name.

=== Track Metadata Item 4: Duration

The fourth item contains track duration information, so argument 7 has
the value `0b`. Argument 2 contains the length, in seconds, of the
track when played at normal tempo.

=== Track Metadata Item 5: Tempo

The fifth item contains tempo information, so argument 7 has the value
`0d`. Argument 2 contains the track’s starting tempo, in beats per
minute, times 100, as reported in _BPM_ values in other packets
described earlier.

=== Track Metadata Item 6: Comment

The sixth item contains comment information, so argument 7 has the
value `23`. Argument 4 contains the text of the track comment entered
by the DJ in rekordbox.

=== Track Metadata Item 7: Key

The seventh item contains key information, so argument 7 has the value
`0f`. Argument 4 contains the text of the track’s dominant key
signature.

=== Track Metadata Item 8: Rating

The eighth item contains rating information, so argument 7 has the
value `0a`. Argument 2 contains a value from 0 to 5 corresponding to
the number of stars the DJ has assigned the track in rekordbox.

=== Track Metadata Item 9: Color

The ninth item contains color information, so argument 7 has a value
between `13` and `1b` identifying the color, if any, assigned to the
track (see TODO: Section 6.5 for the color choices), and if the value
is anything other than `13`, Argument 4 contains the text that the DJ
has assigned for that color meaning in rekordbox.

=== Track Metadata Item 10: Genre

The tenth item contains genre information, so argument 7 has the value
`06`. Argument 2 contains the numeric genre ID, and argument 4
contains the text of the genre name.

=== Track Metadata Item 11: Date Added

The eleventh and final item contains information about the the date
the track was added to the collection, so argument 7 has the value
`2e`. Argument 4 contains the date the track was added to the
collection in the format “yyyy-mm-dd”. This information seems to
propagate into rekordbox from iTunes.

== Menu Footer Response

The menu footer message has a _type_ of `4201` and no arguments, so it
has a header only, and is always made up of the
<<menu-footer-response,exact same sequence of bytes>> (apart from the
_TxID_).





To be continued...

.Cue point response message.
[bytefield]
----
;; Figure 48
include::example$dbserver_shared.edn[]
include::example$cue_point_response.edn[]
----

include::partial$Footer.adoc[]
