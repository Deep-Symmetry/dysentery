= Track Metadata
James Elliott <james@deepsymmetry.org>

Thanks to https://github.com/EvanPurkhiser[@EvanPurkhiser], we finally
started making progress in retrieving metadata from CDJs, and then
some shared code from https://bitbucket.org/awwright/libpdjl[Austin
Wright] boosted our understanding considerably, and led to this
section.

[[connecting]]
== Connecting to the Database

The first step is to determine the port on which the player is
offering its remote database server. That can be determined by opening
a TCP connection to port 12523 on the player and sending it sending
a packet with the following content:

.DB Server query packet.
[bytefield]
----
(draw-column-headers)
(draw-related-boxes (concat [0 0 0 0x0f]
                            (map #(text % :hex) "RemoteDBServer")
                            [0]))
----

The player will send back a two-byte response, containing the high
byte of the port number followed by the low byte. So far, the response
from a CDJ has always indicated a port number of 1051, but using this
query to determine the port to use will protect you against any future
changes. The same query can also be sent to a laptop running rekordbox
to find the rekordbox database server port, which can also be queried
for metadata in the exact same way described below.

To find the metadata associated with a particular track, given its
rekordbox ID number, as well as the player and slot from which it was
loaded (all of which can be determined from a CDJ status packet
received by a virtual CDJ as described in
<<vcdj.adoc#creating-vcdj,Creating a Virtual CDJ>>), open a TCP
connection to the device from which the track was loaded, using the
port that it gave you in response to the DB Server query packet, then
send the following four messages. (You can also get metadata for
non-rekordbox tracks, even for CD Audio tracks being played in the CD
slot, using the variant described in <<non-rekordbox-metadata>>.)

Once you have determined the database port, send it a setup packet
with the following content, and the server will send the same five
bytes back:

.Database connection setup packet.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field 1)
----

All further messages have a shared structure. They consist of lists of
type-tagged fields (a type byte, followed some number of value bytes,
although in the case of the variable-size types, the first four bytes
are a big-endian integer that specifies the length of the additional
value bytes that make up the field). So far, there are four known
field types, and it turns out that the packet we just saw is one of
them, it represents the number 1 as a 4-byte integer.

== Field Types

The first byte of a field identifies what type of field is coming. The
values `0f`, `10`, and `11` are followed by `1`, `2`, and `4` byte
fixed-length integer fields, while `14` and `26` introduce
variable-length fields, a binary blob and a UTF-16 big-endian string
respectively.

=== Number Fields

Number fields are indicated by an initial byte{nbsp}``0f``, `10`, or
`11` which is followed by big-endian integer value of length `1`, `2`,
or `4` bytes respectively, as shown below. So, as noted above, the
initial greeting packet sent to and received back from the database
server is a number field, four bytes long, representing the value 1.

.Number Field of length 1.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 2)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 1)
----

.Number Field of length 2.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 3)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 2)
----

.Number Field of length 4.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math))
----

=== Binary Fields

Variable-length binary (blob) fields are indicated by an initial
byte{nbsp}``14``, followed by a `4` byte big-endian integer which
specifies the length of the field payload. This length is followed by
the specified number of bytes (for example, an album art image,
waveform or beat grid):

.Binary (Blob) Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-binary-field "Binary Data")
(draw-bottom)
----

=== String Fields

Variable-length string fields are indicated by an initial
byte{nbsp}``26``, followed by a `4` byte big-endian integer which
specifies the length of the string, in two-byte UTF-16 big-endian
characters. So the length is folowed by 2 × _length_ bytes containing
the actual string characters. The last character of the string is
always `NUL`, represented by `0000`:

.String Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-string-field "UTF-16BE string")
(draw-bottom)
----

[[messages]]
== Messages

Messages are introduced by a 4{nbsp}byte Number field containing a
“magic“ value (it is always `872349ae`). This is followed by another
4{nbsp}byte number field that contains a transaction ID (_TxID_),
which starts at 1 and is incremented for each query sent, and all
messages sent in response to that query will contain the same
transaction ID. This is followed by a 2{nbsp}byte number field
containing the message _type_, a 1{nbsp}byte number field (_n_)
containing the number of argument fields present in the message, and a
blob field containing a series of bytes which identify the types of
each argument field (shown as _t~1~_ through _t~12~_ below). This blob
is always twelve bytes long, regardless of how few arguments there are
(and presumably this means no message ever has more than twelve
arguments). Tag bytes past the actual argument count of the message
are set to 0.

This header is followed by the fields that make up the message
arguments, if any. In other words, the message body consists of
arguments identified by the header.

.Message structure showing header fields.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-number-field 0x872349ae 4 :bg-green)
(draw-number-field (text "TxID" :math) 4 :bg-yellow)
(draw-number-field (text "type" :math) 2 :bg-pink)
(draw-number-field (text "n" :math) 1 :bg-cyan)
(draw-box 0x14 [:bg-purple {:borders {:left   :border-unrelated
                                      :top    :border-unrelated
                                      :right  :border-related
                                      :bottom :border-related}}])

(draw-box (text "0000000c" :hex [[:plain {:font-weight "lighter" :font-size 16}] " (12)"])
          [{:span 4} [:bg-purple {:borders {:left   :border-related
                                            :top    :border-unrelated
                                            :right  :border-related
                                            :bottom :border-unrelated}}]])
(doseq [i (map inc (range 11))]
  (draw-box (text "t" :math [:sub i]) [:box-related :bg-purple]))
(draw-box (text "t" :math [:sub 12]) [:bg-purple {:borders {:left   :border-related
                                                  :top    :border-related
                                                  :right  :border-unrelated
                                                  :bottom :border-unrelated}}])
(draw-gap "Arguments")
(draw-bottom)
----

The argument type tags use different values than the field type tags
themselves, for some reason, and it is not clear why this redundant
information is necessary at all—but that is true a number of places in
the protocol as we have seen before and will see again. Here are the
known tag values and their meanings:

[[message-argument-tag-values]]
.Argument tag values.
[cols=">1m,<15"]
|===
|Tag |Meaning

|02 |A string in UTF-16 big-endian encoding, with trailing NUL (zero) character.
|03 |A binary blob.
|06 |A 4 byte big-endian integer.
|===

I am guessing that if we ever see them, a tag of `04` would represent
a 1{nbsp}byte integer, and `05` would represent a 2{nbsp}byte integer.
But so far no such messages have been seen.

Before you can send your first actual query, you need to send a
special message which seems to be necessary for establishing the
context for queries. It has a _type_ of `0000`, a special _TxID_ value
of `fffffffe`, and a single numeric argument, like this:

.Query context setup message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0 6)
(draw-number-field (text "D" :math [:sub "ours"]))
----

The value _D_ is, like in the other packets we have seen, a player
device number. In this case it is the device that is asking for
metadata information. It must be a valid player number between 1 and
4, and that player must actually be present on the network, must not
be the same player that you are contacting to request metadata from,
and must not be a player that has connected to that player via Link
and loaded a track from it. So the safest device number to use is the
device number you are using for your virtual CDJ, but since it must be
between 1 and 4, you can only do that if there are fewer than four
actual CDJs on the network.

The player will respond with a message of type `4000`, which is the
common “success” response when requested data is available. The
response message has two numeric arguments, the first of which is the
message type of the request we sent (which was `0000`), and the second
usually tells you the number of items that are available in response
to the query you made, but in this special setup query, it returns its
own player number:

[[query-context-setup-response]]
.Query context setup response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header "0 response" 6 6)
(draw-number-field 0)
(draw-number-field (text "D" :math [:sub "theirs"]))
----

[[track-metadata]]
== Rekordbox Track Metadata

To ask for metadata about a particular rekordbox track, send a packet
like this:

[[track-metadata-request-message]]
.Rekordbox track metadata request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2002 6 6)
(draw-dmst-field 1)
(draw-number-field (text "rekordbox" :math))
----

As described above, _TxID_ should be 1 for the first query packet you
send, 2 for the next, and so on.

The first argument of this message requires a little explanation: it
is sent as a four-byte number field, but each byte has a separate
meaning. _D_ should have the same value you used in your initial query
context setup packet, identifying the device that is asking the
question. The second byte is referred to as _M_, and seems to identify
the particular menu location on the CDJ where results are going to be
displayed. For this kind of metadata request it always has the value
`01`.

_S~r~_ is the slot in which the track being asked about can be found,
and has the same values used in CDJ status packets, as described in
the <<vcdj.adoc#slot-identifiers,CDJ status packet description>>.
Similarly, _T~r~_ identifies the type of track we want information
about; for rekordbox tracks this always has the value `01`.

This first argument format is used for many different requests about
tracks, so it is given the acronym _DMST_ in future discussion.

The second message argument, _rekordbox_, identifies the local
rekordbox database ID of the track being asked about, as found in the
<<vcdj.adoc#cdj-status-packet,CDJ status packet>>.

As suggested in the above description, track metadata requests are
built on the mechanism that is used to request and draw scrollable
menus on the CDJs, so the request is essentially interpreted as
setting up to draw the “menu” of information that is known about the
track. The player responds with a success indicator, saying it is
ready to send these “menu items” and reporting how many of them are
available:

[[metadata-available-response]]
.Track metadata available response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4000 6 6)
(draw-number-field 0x2002)
(draw-number-field 0xb)
----

We’ve seen this type of “data available” response already in the
<<query-context-setup-response,query context setup response>>, but
this one is a more typical example. As usual, _TxID_ matches the value
we sent in our request, and the first argument, with value `2002`,
reflects the _type_ field of our request. The second argument reports
that there are 11 (`0b`) entries of track metadata available to be
retrieved for the track we asked about, and that the player is ready
to send them to us.

If there was no track with ID _rekordbox_ in that media slot, the
second argument would have the value `ffffffff` to let us know. If we
messed up something else about the request, we will get a response
with a _type_ other than `4000`. See <<experimenting-with-metadata>>
for instructions on how to explore these variations on your own.

But assuming everything went well, we can get the player to send us
all eleven of those metadata entries by telling it to render all of
the current menu, using a “render menu” request with _type_ `3000`
like this:

[[render-menu-request]]
.Render Menu request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x3000 6 6 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field (text "offset" :math))
(draw-number-field (text "limit" :math))
(draw-number-field 0)
(draw-number-field (text "total" :math))
(draw-number-field 0)
----

As always, the value of _TxID_ should be one higher than the one you
sent in your setup packet, while the values of _D_, _S~r~_, and _T~r~_
should be identical to what you sent in it.

The request has six numeric arguments. At this point it is worth
talking a bit more about the byte after _D_ in the first argument.
This seems to specify the location of the menu being drawn, with the
value 1 meaning the main menu on the left-hand half of the CDJ
display, while 2 means the submenu (for example the info popup when it
is open) which overlays the right-hand half of the display. We don’t
yet know exactly what, if any, difference there is between the
response details when 2 is used instead of 1 here. And special data
requests use different values: for example, the track waveform
summary, which is drawn in a strip along the entire bottom of the
display, is requested with a menu location number of 8 in this second
byte.

As described above, _T~r~_ has the value 1 for rekordbox tracks.

The second argument, _offset_, specifies which menu entry is the first
one you want to see, and the third argument, _limit_, specifies how
many should be sent. In this case, since there are only 11 entries, we
can request them all at once, so we will set _offset_ to 0 and _limit_
to 11. But for large playlists, for example, you need to request
batches of entries that are smaller than the total available, or the
player will be unable to send them to you. We have not found what the
exact limit is, but getting 64 at a time seems to work on Nexus 2
players.

We don’t know the purpose of the fourth argument, but sending a value
of 0 works. The fifth argument, _total_, seems to usually contain the
total number of items reported in the intial menu response, but
sending a second copy of _limit_ here works too; it may not matter much.
And the sixth and final argument also has an unknown purpose, but 0
works.

So, for our metadata request, the packet we want to send in order to
get all the metadata will have the specific values shown here:

.Render track metadata request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x3000 6 6 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field 0)
(draw-number-field 0xb)
(draw-number-field 0)
(draw-number-field 0xb)
(draw-number-field 0)
----

This causes the player to send us 13 messages: The 11 metadata items
we requested are sent (with _type_ `4101`, <<menu-item-response,second
figure below>>), but they are preceded by a menu header message (with
_type_ `4001`, <<menu-header-response,first figure below>>), and
followed by a menu footer message (with _type_ `4201`,
<<menu-footer-response,third figure below>>). This wrapping happens
with all “render menu” requests, and the menu footer is an easy way to
know you are done, although you can also count the messages.

WARNING: When sending requests which result in multiple response
messages, it is important to keep in mind the distinction between
message boundaries and network packets. You might receive more than
one message in a single network packet (especially when you are
talking to rekordbox), so you need to look for message boundaries
based on the length information in each message. Failure to do this
initially led to a bug in Beat Link. It is also possible that a single
message might be split into more than one network packet. I don't
believe this has been seen, but coding defensively to handle it may be
the reason why.

[[menu-header-response]]
.Menu header response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4001 6 6)
(draw-number-field 1)
(draw-number-field 0)
----

The menu item responses all have the same structure, and use all
twelve message argument slots, containing ten numbers and two strings,
although they generally don’t have meaningful values in all of the
slots. They have the general structure shown here, and the arguments
are listed in the Table <<menu-item-arguments,below>>:

[[menu-item-response]]
.Menu item response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4101 6 6 6 2 6 2 6 6 6 6 6 6)
(draw-gap "Arguments")
(draw-bottom)
----

[[menu-footer-response]]
.Menu footer response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4201)
----

[[menu-item-arguments]]
.Menu item arguments.
[cols=">1,^3,<12"]
|===
|Arg |Type |Meaning

|1 |number |Parent ID, such as an artist for a track item.
|2 |number |Main ID, such as _rekordbox_ for a track item.
|3 |number |Length in bytes of Label 1.
|4 |string |Label 1 (main text, such as the track title or artist name, as appropriate for the item type).
|5 |number |Length in bytes of Label 2.
|6 |string |Label 2 (secondary text, e.g. artist name for playlist entries, where Label 1 holds the title).
|7 |number |Type of this item (see <<menu-item-types>>).
|8 |number |Some sort of flags field, details still unclear.
|9 |number |Holds _artwork_ ID when type is Track Title.
|10 |number |Playlist position when relevant, e.g. when listing a playlist.
|11 |number |Unknown.
|12 |number |Unknown.
|===

[[track-metadata-title]]
=== Item 1: Title

The first item returned after the menu header is the track title, so
argument 7 has the value `04`. Argument 1, which may always be some
kind of parent ID, holds the artist ID associated with the track. The
second argument seems to always be the main ID, and for this response
it holds the _rekordbox_ ID of the track. Argument 4 holds the track
title text, and argument 9 holds the album _artwork_ ID if any is
available for the track. This ID can be used to retrieve the actual
album art image as described in <<album-art>>.

=== Item 2: Artist

The second item contains artist information, so argument 7 has the
value `07`. Argument 2 holds the artist ID, and argument 4 contains
the text of the artist name.

=== Item 3: Album Title

The third item contains album title information, so argument 7 has the
value `02`. Argument 4 contains the text of the album name.

=== Item 4: Duration

The fourth item contains track duration information, so argument 7 has
the value `0b`. Argument 2 contains the length, in seconds, of the
track when played at normal tempo.

=== Item 5: Tempo

The fifth item contains tempo information, so argument 7 has the value
`0d`. Argument 2 contains the track’s starting tempo, in beats per
minute, times 100, as reported in _BPM_ values in other packets
described earlier.

=== Item 6: Comment

The sixth item contains comment information, so argument 7 has the
value `23`. Argument 4 contains the text of the track comment entered
by the DJ in rekordbox.

=== Item 7: Key

The seventh item contains key information, so argument 7 has the value
`0f`. Argument 4 contains the text of the track’s dominant key
signature.

=== Item 8: Rating

The eighth item contains rating information, so argument 7 has the
value `0a`. Argument 2 contains a value from 0 to 5 corresponding to
the number of stars the DJ has assigned the track in rekordbox.

=== Item 9: Color

The ninth item contains color information, so argument 7 has a value
between `13` and `1b` identifying the color, if any, assigned to the
track (see <<menu-item-types-colors,Menu Item Types>> for the color
choices), and if the value is anything other than `13`, Argument 4
contains the text that the DJ has assigned for that color meaning in
rekordbox.

=== Item 10: Genre

The tenth item contains genre information, so argument 7 has the value
`06`. Argument 2 contains the numeric genre ID, and argument 4
contains the text of the genre name.

=== Item 11: Date Added

The eleventh and final item contains information about the the date
the track was added to the collection, so argument 7 has the value
`2e`. Argument 4 contains the date the track was added to the
collection in the format “yyyy-mm-dd”. This information seems to
propagate into rekordbox from iTunes.

== Menu Footer Response

The menu footer message has a _type_ of `4201` and no arguments, so it
has a header only, and is always made up of the
<<menu-footer-response,exact same sequence of bytes>> (apart from the
_TxID_).

[[menu-item-types]]
== Menu Item Types

As noted above, the seventh argument in a menu item response
identifies the type of the item. The meanings we have identified so
far are:

.Known menu item types.
[cols=">1m,<11"]
|===
|Type |Meaning

|0001 |Folder (such as in the playlists menu)footnote:[A nested list of playlists rather than an individual playlist.]
|0002 |Album title
|0003 |Disc
|0004 |Track Title
|0006 |Genre
|0007 |Artist
|0008 |Playlist
|000a |Rating
|000b |Duration (in seconds)
|000d |Tempo
|000e |Label
|000f |Key
|0010 |Bit Rate
|0011 |Year
| |
[[menu-item-types-colors]]
|0013 |Color None
|0014 |Color Pink
|0015 |Color Red
|0016 |Color Orange
|0017 |Color Yellow
|0018 |Color Green
|0019 |Color Aqua
|001a |Color Blue
|001b |Color Purple
| |
|0023 |Comment
|0024 |History Playlist
|0028 |Original Artist
|0029 |Remixer
|002e |Date Added
| |
[[types-for-menus]]
|0080 | Genre menu
|0081 | Artist menu
|0082 | Album menu
|0083 | Track menu
|0084 | Playlist menu
|0085 | BPM menu
|0086 | Rating menu
|0087 | Year menu
|0088 | Remixer menu
|0089 | Label menu
|008a | Original Artist menu
|008b | Key menu
|008e | Color menu
|0090 | Folder menu
|0091 | Search “menu”
|0092 | Time menu
|0093 | Bit Rate menu
|0094 | Filename menu
|0095 | History menu
|00a0 | All
| |
|0204 | Track Title and Album
|0604 | Track Title and Genre
|0704 | Track Title and Artist
|0a04 | Track Title and Rating
|0b04 | Track Title and Time
|0d04 | Track Title and BPM
|0e04 | Track Title and Label
|0f04 | Track Title and Key
|1004 | Track Title and Bit Rate
|1a04 | Track Title and Bit Color
|2304 | Track Title and Comment
|2804 | Track Title and Original Artist
|2904 | Track Title and Remixer
|2a04 | Track Title and DJ Play Count
|2e04 | Track Title and Date Added
|===

As noted above, track metadata responses use many of these types.
Others are used in different kinds of menus and queries.

[[non-rekordbox-metadata]]
== Non-Rekordbox Track Metadata

As discussed in the introduction to this section, you can get metadata
for non-rekordbox tracks as well (although they don’t have beat grids,
waveforms, or album art available). All you need to do is use a slight
variant of the <<track-metadata-request-message,metadata request
message>>, using the value `2202` (instead of `2002`) for the message
type, and a value of _T~r~_ that is appropriate for the kind of track
you are asking about (`02` for non-rekordbox tracks loaded from media
slots, and `05` for CD audio tracks playing in the CD slot, which has
a _S~r~_ value of `01`). After the initial query setup message, the
other message types are the same as in the above discussion, but you
will continue using the _S~r~_ and _T~r~_ values appropriate for the
slot and media type you are asking about.

Since these tracks don’t have rekordbox IDs, you will need to use the
_rekordbox_ value reported in CDJ status packets in order to find out
the values used to request the metadata for tracks loaded from solid
state media; CD tracks are requested using the simple track number
as the _rekordbox_ value.

TIP: It seems that to reliably get data back when requesting metadata
for non-rekordbox tracks, your virtual CDJ needs to be sending
properly-formatted status packets, not just device announcement
packets.

[[album-art]]
== Album Art

To request the artwork image associated with a track, send a message
with _type_ `2003` containing the _artwork_ ID that was specified in
the track title item (as described in <<track-metadata-title>>), like
this:

.Track artwork request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2003 6 6)
(draw-dmst-field 8)
(draw-number-field (text "artwork" :math))
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. Finally, _artwork_
identifies the specific artwork image you are requesting, as it was
specified in the track medatata response. As with other graphical
requests, the value after _D_, which identifies the location of the
menu for which data is being loaded, is 8.

The response will be a message with _type_ `4002`, containing four
arguments. The first argument echoes back our request type, which was
`2003`. The second always seems to be 0. The third contains the length
of the image in bytes, which seems redundant, because that is also
conveyed in the fourth argument itself, a blob containing the actual
bytes of the image data, as shown below. However, if there is no image
data, this value will be 0, and the blob field will be completely
omitted from the response, so you _must not_ try to read it!

.Track artwork response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4002 6 6 6 3)
(draw-number-field 0x2003)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Image bytes" {:length-label (text "length" :math)})
(draw-bottom)
----

To experiment with this, start up dysentery in a Clojure REPL and
connect to a player as described in <<experimenting-with-metadata>>,
then evaluate an expression like:

[source,clojure]
----
(def art (db/request-album-art p2 3 3))
----

Replace the arguments with the `var` holding your player connection,
the proper _S~r~_ number for the media slot holding the art, and the
_artwork_ ID of the album art, and dysentery will open a window like
this showing the image:

image::Album-art-example.png[alt=Album Art,width=213,height=152]

To load artwork for a non-rekordbox track, add an additional argument
with the value 2 at the end.

== Beat Grids

The CDJs do not send any timing information other than beat numbers
during playback, which has made it difficult to offer absolute
timecode information. The discovery of beat grid requests provides a
clean answer to the problem. The beat grid for a track is a list of
every beat which occurs in the track, along with the point in time at
which that beat would occur if the track were played at its standard
(100%) tempo. Armed with this table, it is possible to translate any
beat packet into an absolute position within the track, and, combined
with the tempo information, to generate timecode signals allowing
other software (such as video resources) to sync tightly with DJ
playback.

To request the beat grid of a track, send a message with _type_ `2204`
containing the _rekordbox_ ID of the track:

.Track beat grid request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2204 6 6)
(draw-dmst-field 8)
(draw-number-field (text "rekordbox" :math))
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. Finally, _rekordbox_
identifies the specific beat grid you are requesting, as found in a
CDJ status packet or playlist response. As with graphical requests,
the value after 𝐷, which identifies the location of the menu for which
data is being loaded, is 8.

The response will be a message with _type_ `4602`, containing four
arguments. The first argument echoes back our request type, which was
`2204`. The second always seems to be 0. The third contains the length
of the beat grid in bytes, which seems redundant, because that is also
conveyed in the fourth argument itself, which is a blob containing the
actual bytes of the beat grid, as shown below. However, if there is no
beat grid available, this value will be 0, and the blob field will be
completely omitted from the response, so you _must not_ try to read it!

.Track beat grid response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4602 6 6 6 3)
(draw-number-field 0x2204)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Beat grid bytes" {:length-label (text "length" :math)})
(draw-bottom)
----

The beat grid itself is spread through the value returned as argument
4, consisting of a series of sixteen-byte entries with the following
structure:

.Beat Grid entry.
[bytefield]
----
(def left-margin 1)
(draw-column-headers)
(draw-box (text "B" :math [:sub "b"]) {:span 2})
(draw-box (text "tempo" :math) {:span 2})
(draw-box (text "time" :math) {:span 4})
(draw-box "Unknown" {:span 8})
----

Each entry begins with a two-byte little-endian{empty}footnote:[Yes,
unlike almost all numbers in the protocol, beat grid and cue point
times are little-endian.] integer holding the beat-within-bar number
(labeled _B~b~_ in the <<vcdj.adoc#cdj-status-packet,CDJ status packet
diagram>>) of the beat, which is always 1, 2, 3, or 4. This is
followed by a two-byte little-endian _tempo_ value, which records the
track tempo at the point where this beat occurs, in beats per minute
multiplied by 100 (to allow a precision of stem:[\frac{1}{100}] BPM).
Finally, there is a four-byte little-endian _time_ value, which
specifies the time at which this beat would occur, in milliseconds,
when playing the track at its normal speed.

In other words, the _B~b~_ value of the first beat in the track is
found at bytes{nbsp}``0x14``-`15` of argument 4, its _tempo_ at
bytes{nbsp}``16``-`17`, and the _time_ at which that beat occurs at
bytes{nbsp}``18``–`1b`. Subsequent beats are found at `0x10`-byte
intervals, so the second _B~b~_ value is found at
bytes{nbsp}``24``-`25`, its _tempo_ at bytes{nbsp}``26``-`27`, its
_time_ at bytes{nbsp}``28``-`2b`, and so on.

The purpose of the other bytes within the beat grid is so far
undetermined. It looks like there may be some sort of monotonically
increasing value following the beat millisecond value, but what it
means, and why it sometimes skips values, is mysterious.

== Requesting Track Waveforms

Waveform data for tracks can be requested, both the preview, which is
400 pixels long, and the detailed waveform, which uses 150 pixels per
second of track content. There is also an even tinier 100 pixel
preview, which is used by older players such as the pre-Nexus CDJ 900,
returned as the final 100 bytes of the preview response.

NOTE: We also know how to request Nxs2-style higher resolution and
color waveforms, see <<requesting-nxs2-waveforms>> for details.

=== Waveform Previews

To request the waveform preview of a track, send a message with _type_
`2004` containing the _rekordbox_ ID of the track:

.Waveform preview request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2004 6 6 6 6 3)
(draw-dmst-field 8)
(draw-number-field 4)
(draw-number-field (text "rekordbox" :math))
(draw-number-field 0)
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. Finally, _rekordbox_
identifies the specific waveform preview you are requesting, as found
in a CDJ status packet or playlist response. As with other graphical
requests, the value after 𝐷, which identifies the location of the menu
for which data is being loaded, is 8.

NOTE: You may have noticed that the argument list of the above message
specifies that there are five arguments, but in fact the message
contains only the first four, numeric, arguments. The fifth, blob,
argument is missing. This seems to imply the blob is empty, and this
very strange feature of the protocol is, in fact, the way the track
metadata is requested. The fifth argument must be specified in the
message header but not actually present. When reading messages from a
player, the same rules apply: There is always a numeric field right
before a blob field, and it always contains a seemingly-redundant copy
of the blob length, and if that numeric field has the value 0, you
must not try to read the blob field. Instead, expect the next field to
follow the numeric field (or, if the blob was the last field, expect
the message to end with the numeric field).

The second argument has an unknown purpose, but we have seen values of
3 or 4 for it. The fourth argument is the size of the binary blob
argument we are supposedly going to send; since we are not actually
sending a blob, we always send a 0 here.

The response will be a message with _type_ `4402`, containing four
arguments. The first argument echoes back our request type, which was
`2004`. The second always seems to be 0. The third contains the length
of the waveform preview in bytes. If this value is 0, the fourth
argument will be omitted from the response. When present, the fourth
argument is a blob containing the actual bytes of the waveform
preview, as shown below.

.Waveform preview response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4402 6 6 6 3)
(draw-number-field 0x2004)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Waveform preview bytes" {:length-label (text "length" :math)})
(draw-bottom)
----

For this kind of waveform preview request, there are 900 (decimal)
bytes of waveform data returned. The first 800 of them contain 400
columns of waveform data, in the form of two-byte pairs, where the
first byte is the pixel height of the waveform at that column (a value
ranging from 0 to 31), and the second byte represents whiteness, where
0 is blue and 7 is fully white. My players seem to only pay attention
to the highest bit of whiteness, drawing the waveform as either very
dark or light blue accordingly.

To experiment with this, start up dysentery in a Clojure REPL and
connect to a player as described in <<experimenting-with-metadata>>,
then evaluate an expression like:

[source,clojure]
----
(db/request-waveform-preview p2 3 1060)
----

Replace the arguments with the `var` holding your player connection,
the proper _S~r~_ number for the media slot the track is found in, and
the _rekordbox_ ID of the track, and dysentery will open a window
like this showing the waveform preview:

[[player-display]]
image::Wave-preview-example.png[alt=Waveform preview,width=433,height=86]

The remaining hundred bytes appear to contain an even more compact
100-column preview representation of the waveform which is shown on
pre-Nexus CDJ 900 players as shown below. Our best guess is that for
each byte, the four low- order bits encode the height of the waveform
in that column, and the high-order bits may encode saturation again?

image::Tiny-preview-example.png[alt=Tiny waveform preview,width=737,height=332]

=== Detailed Waveforms

Requesting the detailed waveform is very similar to requesting the
preview, but the request type and arguments are slightly different. To
request the detailed waveform of a track, send a message with _type_
`2904` containing the _rekordbox_ ID of the track, like the one shown
below:

.Waveform detail request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2904 6 6 6)
(draw-dmst-field 8)
(draw-number-field (text "rekordbox" :math))
(draw-number-field 0)
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. Finally, _rekordbox_
identifies the specific waveform preview you are requesting, as found
in a CDJ status packet or playlist response. Since this is a graphical
request, I would expect the value after _D_, which identifies the
location of the menu for which data is being loaded, to be 8 like it
is for others, but for some reason it is 1, which usually means the
main menu... maybe because the scrolling waveform appears in the same
location on the display as the main menu? In many ways this protocol
is a mystery wrapped in an enigma.

The waveform detail response is essentially identical to the waveform
preview response, with just the type numbers changed. It will be a
message with _type_ `4a02`, containing four arguments. The first
argument echoes back our request type, which was `2904`. The second
always seems to be 0. The third contains the length of the waveform
detail in bytes. If this value is 0, the fourth argument will be
omitted from the response. When present, the fourth argument is a blob
containing the actual bytes of the waveform detail, as shown below:

.Waveform detail response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4a02 6 6 6 3)
(draw-number-field 0x2904)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Waveform  bytes" {:length-label (text "length" :math)})
(draw-bottom)
----

The content of the waveform detail is simpler and more compact than
the waveform preview. Every byte reperesents one segment of the
waveform, and there are 150 segments per second of audio. (These seem
to correspond to “half frames” following the seconds in the player
display.) Each byte encodes both a color and height. The three
high-order bits encode the color, ranging from darkest blue at 0 to
near-white at 7. The five low-order bits encode the height of the
waveform at that point, from 0 to 31 pixels.

[[frames]]
.Frames
****
There are various places in the protocol and exported database files
that refer to track playback positions in terms of frames or half
frames. This probably comes from the language of digital audio files.
In the case of CDJs, audio is played at the rate of 75 frames per
second, and the formats can address locations that are at half-frame
boundaries, or 150 distinct track locations per second of audio.

You can see this reflected on the <<player-display,player display>>
where time is counted in units of minutes, seconds, and frames, and
the frame field has a decimal point, but the value displayed always
ends with `.0` or `.5`, and ranges from `00.0` to `74.5`.
****

[[requesting-nxs2-waveforms]]
== Requesting Nxs2 Track Waveforms

Thanks to some
https://github.com/Deep-Symmetry/dysentery/issues/9[wonderful
analysis] by https://github.com/jan2000[@jan2000] we now know how to
request and interpret the higher resolution and color waveforms
supported by the nxs2 series of players.

Both the enhanced waveform preview and enhanced detail are requested
using variations on the same request type, which asks for specific
content from the `ANLZ0000.EXT` file created by rekordbox. See the
https://github.com/Deep-Symmetry/crate-digger[Crate Digger project]
which has its own analysis document, if you would like to learn more
about the structure and content of these files.

To request the enhanced waveform preview of a track, send a message
with _type_ `2c04` containing the _rekordbox_ ID of the track, the tag
type identifier `PWV4` and the file extension identifier `EXT` encoded as
four-byte numbers, holding the ASCII in big-endian (backwards) order:

.Nxs2 waveform preview request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2c04 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field (text "rekordbox" :math))
(draw-related-boxes [0x11 0x34 0x56 0x57 0x50])
(draw-related-boxes [0x11 0x00 0x54 0x58 0x45])
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. For some reason the
value after _D_, which identifies the location of the menu for which
data is being loaded, is 1 in this case, rather than the 8 we would
expect to see for a graphical data request. _rekordbox_ identifies the
specific track whose analysis you are requesting, as found in a CDJ
status packet or playlist response, and the final two numeric
arguments specify that you are interested in the `PWV4` tag (which
holds the enhanced waveform preview) from the track’s `EXT` extended
analysis file.

The response will be a message with _type_ `4f02`, containing five
arguments. The first argument echoes back our request type, which was
`2c04`. The second always seems to be 0. The third contains the length
of the requested tag (holding the enhanced waveform preview) in bytes.
If this value is 0, the fourth argument will be omitted from the
response. When present, the fourth argument is a blob containing the
actual bytes of the enhanced waveform preview, as shown below. The
fifth argument has an unknown purpose and so far seems to always have
the value 0.

.Nxs2 waveform preview response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4f02 6 6 6 3 6)
(draw-number-field 0x2c04)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Extended waveform preview bytes" {:length-label (text "length" :math)})
(draw-bottom)
(draw-number-field 0)
----

The extended preview data begins at byte `34` and is 7,200 (decimal)
bytes long, representing 1,200 columns of waveform preview
information.

[[color-preview-analysis]]
The color waveform preview entries are the most complex of any of the
waveform tags. See the
https://github.com/Deep-Symmetry/dysentery/issues/9[discussion on
Github] for how the analysis was performed. @jan2000 created an audio
file containing a 10 second sine wave sweep from 20 Hz to 20 kHz, and
analyzed that in rekordbox. The results looked like this:

image::sine-sweep-preview.png[alt=Sine sweep preview,width=617,height=480]

As a summary, the top six stripes plot the values of each six channels
of waveform preview information. The first byte of data is the first
column of the top stripe, the next byte is the first column of the
second stripe, and so on, until we reach the seventh byte, which is
the second column of the first stripe.

We are not sure what the top two stripes represent, but they do seem
to have an effect on the blue version of the waveform preview, so they
somehow encode “whiteness”. The next stripe, corresponding to byte 2
of each column, indicates how much sound energy is present in the
bottom half of the frequency range (it drops around 10 KHz). The
stripe corresponding to byte 3 reflects how much sound energy is
present in the bottom third of the frequency range, byte 4 reflects
how much sound energy is in the middle of the frequency range, and
byte 5 tracks the sound energy in the top of the frequency range.

The stripe labeled “color” reflect’s @jan2000’s algorithm for
combining bytes 3, 4, and 5 into a color preview, and the bottom
stripe is his approach for deriving the blue preview from that and the
other two stripes.

The calculations used by Beat Link to build its own color previews can
be found in
https://github.com/Deep-Symmetry/beat-link/blob/v0.6.1/src/main/java/org/deepsymmetry/beatlink/data/WaveformPreview.java#L234-L262[the
`segmentColor`] and
https://github.com/Deep-Symmetry/beat-link/blob/v0.6.1/src/main/java/org/deepsymmetry/beatlink/data/WaveformPreview.java#L208-L232[`segmentHeight`
methods] of the
https://deepsymmetry.org/beatlink/apidocs/org/deepsymmetry/beatlink/data/WaveformPreview.html[`WaveformPreview`
class], and the way they are used to draw the actual graphical
representation can be found in the
https://github.com/Deep-Symmetry/beat-link/blob/v0.6.1/src/main/java/org/deepsymmetry/beatlink/data/WaveformPreviewComponent.java#L426-L448[`updateWaveform`
method] of the
https://deepsymmetry.org/beatlink/apidocs/org/deepsymmetry/beatlink/data/WaveformPreviewComponent.html[`WaveformPreviewComponent`
class]. These produce attractive results, but it is certainly possible
that refinements can be found in the future.

As mentioned, requesting the detailed color waveform is a simple
variant of the request used to obtain the preview. The same request
type is used, and the only difference is that the tag type requested
to obtain the scrollable detail view is `PWV5`. The full request is
shown here:

.Nxs2 waveform detail request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2c04 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field (text "rekordbox" :math))
(draw-related-boxes [0x11 0x35 0x56 0x57 0x50])
(draw-related-boxes [0x11 0x00 0x54 0x58 0x45])
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. For some reason the
value after _D_, which identifies the location of the menu for which
data is being loaded, is 1 in this case, rather than the 8 we would
expect to see for a graphical data request. _rekordbox_ identifies the
specific track whose analysis you are requesting, as found in a CDJ
status packet or playlist response, and the final two numeric
arguments specify that you are interested in the `PWV5` tag (which
holds the enhanced waveform detail) from the track’s `EXT` extended
analysis file.

The response will be a message with _type_ `4f02`, containing five
arguments. The first argument echoes back our request type, which was
`2c04`. The second always seems to be 0. The third contains the length
of the requested tag (holding the enhanced waveform detail) in bytes.
If this value is 0, the fourth argument will be omitted from the
response. When present, the fourth argument is a blob containing the
actual bytes of the enhanced waveform segments, as shown below. The
fifth argument has an unknown purpose and so far seems to always have
the value 0.

.Nxs2 waveform detail response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4f02 6 6 6 3 6)
(draw-number-field 0x2c04)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Extended waveform detail bytes" {:length-label (text "length" :math)})
(draw-bottom)
(draw-number-field 0)
----

The extended waveform detail data begins at byte `34` and has a
variable length, but a vastly simpler structure than the waveform
preview. Every pair of bytes represents one segment of the waveform,
and there are 150 (decimal) segments per second of audio. (These seem
to correspond to “half <<frames,frames>>” following the seconds in the
player display.) Each pair of bytes encodes the height of the waveform
at that segment as a five bit value, along with three bits each of
red, green, and blue intensity, arranged as shown below:

.Nxs2 waveform detail segment bits.
[bytefield]
----
(def left-margin 1)
(draw-column-headers {:labels (str/split "f,e,d,c,b,a,9,8,7,6,5,4,3,2,1,0" #",")})
(draw-box (text "red" :math) {:span 3})
(draw-box (text "green" :math) {:span 3})
(draw-box (text "blue" :math) {:span 3})
(draw-box (text "height" :math) {:span 5})
(draw-related-boxes [0 0])
----

[[requesting-cues]]
== Requesting Cue Points and Loops

NOTE: This section discusses how to obtain cue points and loops which
are compatible with original nexus players. See
<<requesting-nxs2-cues>> for how you can obtain a newer format which
includes hot cue colors, DJ-assigned comment text, and hot cues
beyond C.

The locations of the cue points and loops stored in a track can be
obtained with a request like this:

.Cue point request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2104 6 6)
(draw-dmst-field 8)
(draw-number-field (text "rekordbox" :math))
----

As always, _TxID_ should be incremented each time you send a query,
and will be used to identify the response messages. _D_ should have
the same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. The value after _D_,
which identifies the location of the menu for which data is being
loaded, is 8 which is what we expect for a graphical or data request.
_rekordbox_ is the datbase ID of the specific track whose cue points
you are requesting, as found in a CDJ status packet or playlist
response.

The response will be a message with _type_ `4702`, containing nine
arguments. The first argument echoes back our request type, which was
`2104`. The second always seems to be 0. The third contains the length
of the blob containing cue and loop points in bytes, which seems
redundant, because that is also conveyed in the fourth argument
itself, which is a blob containing the actual bytes of the cue and
loop points, as shown below. However, if there are no cue or loop
points, this value will be 0, and the following blob field will be
completely omitted from the response, so you _must not_ try to read
it!

.Cue point response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
include::example$cue_point_response.edn[]
----

The fifth argument is a number with uncertain purpose. It always seems
to have the value `0x24`, which may be telling us the size of each
cue/loop point entry in argument 4 (they do seem to each take up `24`
bytes, as shown below). The sixth argument, shown as _num~hot~_, seems
to contain the number of hot cue entries found in argument 4, and the
seventh, _num~cue~_ seems to contain the number of ordinary memory
point cues. The eighth argument is a number containing the length of
the second binary field which follows it. We don’t know the meaning of
the final, binary, argument.

As described above, the first binary field in the cue point response
is divided up in to `24`-byte entries, each of which potentially holds
a cue or loop point. They are not in any particular order, with
respect to the time at which they occur in the track. They each have
the structure shown below:

.Cue/loop point entry.
[bytefield]
----
(draw-column-headers)
(draw-box (text "F" :math [:sub "l"]))
(draw-box (text "F" :math [:sub "c"]))
(draw-box (text "H" :math))
(draw-related-boxes (repeat 9 0))
(draw-box (text "cue" :math) {:span 4})
(draw-box (text "loop" :math) {:span 4})
(draw-related-boxes (repeat 16 0))
----

The first byte, _F~l~_, has the value `01` if this entry specifies a
loop, or `00` otherwise. The second byte, _F~c~_, has the value `01`
if this entry contains a cue point, and `00` otherwise. Entries with
loops have the value `01` in both of these bytes, because loops also
act as cue points. If both values are `00`, the entry is ignored (it
is probably a leftover cue point that was deleted by the DJ). The
third byte, labeled _H_, is `00` for ordinary cue points, but has a
non-zero value if this entry defines a hot cue. Hot cues A through C
are represented by the values `01`, `02`, and `03`.

The actual location of the cue and loop points are in the values _cue_
and _loop_. These are both 4-byte integers, and like beat grid
positions, but unlike essentially every other number in the protocol,
they are sent in little-endian byte order. For non-looping cue points,
only _cue_ has a meaning, and it identifies the position of the cue
point in the track, in stem:[\frac{1}{150}] second units. For loops,
_cue_ identifies the start of the loop, and _loop_ identifies the end
of the loop, again in stem:[\frac{1}{150}] second units.

[[requesting-nxs2-cues]]
== Requesting Nxs2 Cue Points and Loops

For tracks that have been exported since the introduction of the nxs2
series of players, rekordbox includes a richer set of information
about cue points and loops. In addition to the information described
in <<requesting-cues>>, you can learn about any custom colors a DJ has
assigned to their hot cues, as well as optional text comments
describing hot cues, memory points, and loops. And while older players
only supported hot cues A through C, this new format returns more.

TIP: In order to work well in mixed-player environments, the firmware
of even older players has been updated to return this information if
it is found in the exported data, so it is worth trying to ask for it.
If the query described in this section fails, then you can fall back
on the one shown in <<requesting-cues>>.

Enhanced information about the cue points and loops stored in a track
can be obtained with a request like this:

.Extended cue point request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2b04 6 6 6)
(draw-dmst-field 8)
(draw-number-field (text "rekordbox" :math))
(draw-number-field 0)
----

As always, _TxID_ should be incremented each time you send a query,
and will be used to identify the response messages. _D_ should have
the same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. The value after _D_,
which identifies the location of the menu for which data is being
loaded, is 8 which is what we expect for a graphical or data request.
_rekordbox_ is the datbase ID of the specific track whose extended cue
information you are requesting, as found in a CDJ status packet or
playlist response.

The response will be a message with _type_ `4e02`, containing five
arguments. The first argument echoes back our request type, which was
`2b04`. The second always seems to be 0. The third contains the length
of the blob containing cue and loop points in bytes, which seems
redundant, because that is also conveyed in the fourth argument
itself, which is a blob containing the actual bytes of the cue and
loop points, as shown below. However, if there are no cue or loop
points, this value will be 0, and the following blob field will be
completely omitted from the response, so you _must not_ try to read
it!

.Extended cue point response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4e02 6 6 6 3 6)
(draw-number-field 0x2b04)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Cue and loop point bytes" {:length-label (text "length" :math)})
(draw-bottom)
(draw-number-field (text "num" :math [:sub "entries"]))
----

The fifth argument reports the number of cue point entries found in
the blob. Because each extended cue entry can include a comment
string, they have variable lengths, so each entry needs to be examined
in order to figure out where it ends, and therefore the next one
begins. The extended entry structure is shown below:footnote:[Thanks
to Matt Positive, https://soundcloud.com/mattpositive, for packet
captures!]

.Extended cue/loop point entry.
[bytefield]
----
(draw-column-headers)
(draw-box (text "length" :math) {:span 4})
(draw-box (text "H" :math))
(draw-box 0)
(draw-box (text "F" :math [:sub "l"]))
(draw-related-boxes (repeat 5 nil))
(draw-box (text "cue" :math) {:span 4})
(draw-box (text "loop" :math) {:span 4})
(draw-related-boxes (repeat 0xe nil))
(draw-box (text "c" :math [:sub "id"]))
(draw-related-boxes (repeat 0x25 nil))
(draw-box (text "len" :math [:sub "c"]) {:span 2})
(draw-gap (text "comment" :math) {:min-label-columns 5})
(draw-related-boxes (repeat 4 nil))
(draw-box (text "c" :math))
(draw-box (text "r" :math))
(draw-box (text "g" :math))
(draw-box (text "b" :math))
(draw-related-boxes (repeat 0x10 nil))
----

The first four bytes, _length_, hold the length of the current entry,
and so can be used to find the start of the next entry. Like other
numbers in cue point responses (and unlike most numbers in the
protocol), this is sent in little-endian byte order. The fourth byte,
labeled _H_, is `00` for ordinary cue points, but has a non-zero value
if this entry defines a hot cue. Hot cues A through H are represented
by the values `01` through `08`.

_F~l~_, at byte{nbsp}``06`` has the value `01` if this entry specifies
a memory point and `02` if it is a loop. If both _H_ and _F~l~_ are
`00`, the entry should be ignored (it is probably a leftover cue point
that was deleted by the DJ).

The actual location of the cue and loop points are in the values _cue_
at bytes{nbsp}``0c``-`0f` and _loop_ at bytes{nbsp}``10``-`13`. These
are both 4-byte integers, and as noted above, they are sent in a
little-endian byte order. For non-looping cue points, only _cue_ has a
meaning, and it identifies the position of the cue point in the track,
in stem:[\frac{1}{150}] second units. For loops, _cue_ identifies the
start of the loop, and _loop_ identifies the end of the loop, again in
stem:[\frac{1}{150}] second units.

_c~id~_ at byte{nbsp}``22`` is used only for ordinary memory points
and loops. If it has a non-zero value, it identifies a row in the
<<rekordbox-export-analysis::exports.adoc#color-rows,color table>>
that specifies the color the user assigned to the memory point or
loop. Hot cues have their own color information later in the entry.

WARNING: Some extended cue entries are incomplete, and their _length_
indicates they end before the comment, or include the comment but end
before the hot cue color information. Code that processes them needs
to be prepared to handle this, and treat such partial cues as having
no comment and/or hot cue color.

_len~c~_ at byte{nbsp}``48`` is a two-byte, little-endian integer that
contains the length of the comment. If it is zero, there is no
comment. Otherwise, _comment_ will follow _len~c~_, taking up that
many bytes, as a string (in UTF-16 encoding with a trailing `0000`
character). So if _len~c~_ isn’t zero, it will be an even number with
minimum value four, representing a comment that is one character long.

Four bytes past the end of _comment_ (in other words, starting
_len~c~_ + `4e` past the start of the entry) there are four one-byte
values containing hot cue color information. 𝑐 appears to be a code
identifying the color with which rekordbox displays the cue, by
looking it up in a table. There have been sixteen codes identified,
and their corresponding RGB colors can be found by looking at the
`findRecordboxColor` static method in the Beat Link library’s
https://github.com/Deep-Symmetry/beat-link/blob/master/src/main/java/org/deepsymmetry/beatlink/data/CueList.java[`CueList`
class]. The next three bytes, _r_, _g_, and _b_, make up an RGB color
specification which is similar, but not identical, to the color that
rekordbox displays. We believe these are the values used to illuminate
the RGB LEDs in a player that has loaded the hot cue. When no color is
associated with the hot cue, all four of these bytes have the value
`00`.

We do not know what, if anything, is sent in the remaining bytes of
the the entry, so they are shown as blank in the byte field diagram
above.

[[requesting-all-tracks]]
== Requesting All Tracks

If you want to cache all the metadata associated with a media stick,
this query is a good starting point. Send a packet with _type_ `1004`:

.Full track list request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x1004 6 6)
(draw-dmst-field 1)
(draw-number-field (text "sort" :math))
----

As always, _TxID_ should be 1 for the first query packet you send, 2
for the next, and so on. _D_ should have the same value you used in
your initial query context setup packet, identifying the device that
is asking the question. _S~r~_ is the slot in which the track being
asked about can be found, and _T~r~_ is the type of the track; these
two bytes have the same values used in <<vcdj.adoc#cdj-status-packet,CDJ
status packets>>. The _sort_ parameter determines the order in which
the tracks are sorted, and that also affects the item type returned,
along with the secondary information (beyond the title) that it
contains about the track, as described in
<<alternate-track-sort-orders>> below. We will start out assuming the
tracks are being requested in title order, which can be done by
sending a _sort_ argument value of 0, and that the DJ has configured
the media device to show artists as the second column.

Track list requests (just like metadata requests) are built on the
mechanism that is used to request and draw scrollable menus on the
CDJs, explored in more breadth in <<menus.adoc#,Menu
Requests>>. The player responds with a success indicator, saying it is
ready to send these “menu items” and reporting how many of them are
available, much like shown in the
<<metadata-available-response,metadata available response>>, although
the first argument will be `1004` to reflect the message type we just
sent, rather than `2002` as it was for the metadata request.

As with metadata, the next step is to send a
<<render-menu-request,“render menu” request>> to get the actual
results. But the number of results available is likely to be much
higher than in the earlier example, because we have asked about all
tracks in the media slot. That means we will probably need more than
one “render menu” request to get them all.

I don’t know how many items you can safely ask for at one time. I have
had success with values as high as 64 on my CDJ-2000 nexus players,
but they failed when asking for numbers in the thousands. So to be
safe, you should ask for the results in chunks of 64 or smaller, by
setting _limit_ and _total_ to the lesser of 64 and the remaining
number of results you want, and incrementing _offset_ by 64 in each
request until you have retrieved them all.

As with metadata requests, you will get back two more messages than
you ask for, because you first get a <<menu-header-response,menu
header message>> (with _type_ `4001`), then the requested
<<menu-item-response,menu items>> are sent (with _type_ `4101`), and
finally these are followed by a <<menu-footer-response,menu footer
message>> (with _type_ `4201`). This wrapping happens with all “render
menu” requests, and the menu footer is an easy way to know you are
done, although you can also count the messages.

The details of the menu items are slightly different than in the case
of a metadata request. In the example where you are retrieving tracks
in the default order, with the second column configured to be artists,
they will have the content shown in the following table:

.Track List entries with Artists.
[cols=">1,^2,<13"]
|===
|Arg |Type |Meaning

|1 |number |artist id
|2 |number |_rekordbox_ id of track
|3 |number |length in bytes of Label 1
|4 |string |Label 1: Track Title
|5 |number |length in bytes of Label 2
|6 |string |Label 2: Artist Name
|7 |number |type of this item, `0704` for “Title and Artist”
|8 |number |some sort of flags field, details still unclear
|9 |number |unknown
|10|number |unknown
|11|number |unknown
|12|number |unknown
|===

[[alternate-track-sort-orders]]
== Alternate Track List Sort Orders

As noted above, you can request the track list in a diferent order by
supplying a different value for the _sort_ parameter. The value 0
gives the order just described, with the default second column
information configured for the media. The _sort_ values discovered so
far are shown in the following table, and return menu items with the
specified item type values in argument 7.

In all these alternate orders, Arg 2 still holds the ID of the track,
and Arg 4 (Label 1) its title, but Arg 1 holds a different ID
depending on the sort chosen, and Arg 6 (Label 2) a different string,
as described in the table:

.Sort Orders.
[cols=">1m,^1m,<2,<2,<2"]
|===
|Sort |Type |Sorted By |Arg 1 |Arg 6 (Label 2)

|01 |0704 |Title |Artist ID |Artist name
|02 |0704 |Artist name |Artist ID |Artist name
|03 |0204 |Album name | Album ID |Album name
|04 |0d04 |BPM | BPM × 100 |empty
|05 |0a04 |Rating |Rating |empty
|06 |0604 |Genre |Genre ID |Genre name
|07 |2304 |Comment |Comment ID |Comment text
|08 |0b04 |Time (track duration) |Length in seconds |empty
|09 |2904 |Remixer |Remixer ID |Remixer name
|0a |0e04 |Label |Label ID |Label name
|0b |2804 |Original Artist |Original Artist ID |Original Artist name
|0c |0f04 |Key |Key ID |Key text
|0d |1004 |Bit rate |Bit rate |empty
|10 |2a04 |DJ play count |Play count |empty
|11 |2e04 |Date added |Date ID |Date text
|===

To experiment with this, start up dysentery in a Clojure REPL and
connect to a player as described in <<experimenting-with-metadata>>,
then evaluate an expression like:

[source,clojure]
----
(db/request-track-list p2 3)
----

Replace the arguments with the `var` holding your player connection
and the proper _S~r~_ number for the media slot containing the tracks
you want to list. You can also add a third argument to specify a sort
order, like this to sort all the tracks in the USB slot by BPM:

[source,clojure]
----
(db/request-track-list p2 3 4)
----

[[playlist-requests]]
== Playlists

If you want to allow your user to browse the content of the media, you
can navigate the playlist folder hierarchy and deal with only specific
playlists. This process is essentially the same as asking for all
tracks, except that in the playlist request you specify the playlist
or folder that you want to list. To start at the root of the playlist
folder hierarchy, you request folder 0. A playlist request has the
following structure:

[[playlist-request-message]]
.Playlist request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x1105 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field (text "sort" :math))
(draw-number-field (text "id" :math))
(draw-number-field (text "folder?" :math))
----

As always, _TxID_ should be 1 for the first query packet you send, 2
for the next, and so on. _D_ should have the same value you used in
your initial query context setup packet, identifying the device that
is asking the question. _S~r~_ is the slot in which the track being
asked about can be found, and _T~r~_ is the type of the track; these
two bytes have the same values used in
<<vcdj.adoc#cdj-status-packet,CDJ status packets>>. You specify the ID
of the playlist or folder you want to list in the _id_ argument, and
set _folder?_ 1 if you are asking for a folder, and 0 if you are
asking for a playlist. As noted above, to get the top-level list of
playlists, ask for folder 0, by passing an _id_ of 0 and passing
_folder?_ as 1.

Much as when listing all tracks, the response may tell you there are
more entries in the playlist than you can retreive in a single
request, so you should follow the procedure outlined in
<<requesting-all-tracks>> to request your results in smaller batches.
The followup queries that you send are identical for playlists as they
are described in that section. The actual menu items returned when you
are asking for a folder have the content shown in the following table:

.Folder List entries.
[cols=">1,^2,<13"]
|===
|Arg |Type |Meaning

|1 |number |parent folder id
|2 |number |id of playlist or folder
|3 |number |length in bytes of Label 1
|4 |string |Label 1: Name of playlist or folder
|5 |number |length in bytes of Label 2
|6 |string |Label 2: empty
|7 |number |type of this item, `01` for folder, `08` for playlist
|8 |number |unknown
|9 |number |unknown
|10|number |playlist position
|11|number |unknown
|12|number |unknown
|===

When you have requested a playlist (by passing its _id_ and a value of
0 for _folder?_) the responses you get are track list entries, just
like when you request all tracks as shown in
<<requesting-all-tracks>>. And just as in that section, you can get
the results in a particular order by specifying a value for _sort_.
The supported values and corresponding item types returned seem to be
the same as described there. Additionally, if you pass a _sort_ value
of `09`, the playlist entries will come back sorted by track title,
Label 2 will be empty, and the item type will be `2904`.

To experiment with this, start up dysentery in a Clojure REPL and
connect to a player as described in <<experimenting-with-metadata>>,
then evaluate an expression like:

[source,clojure]
(db/request-playlist p2 3 1)

Replace the arguments with the `var` holding your player connection,
the proper _S~r~_ number for the media slot containing the playlist
you want to list, and the playlist ID. You can also add a third
argument to specify that you want to list a folder, like this using
folder ID 0 to request the root folder:

[source,clojure]
(db/request-playlist p2 3 0 true)

Finally, you can add a fourth argument to specify a sort order,
like this to sort all the tracks in playlist 12 by genre:

[source,clojure]
(db/request-playlist p2 3 12 false 6)

== Disconnecting

If you want to be polite about the fact that you are done talking to
the `dbserver`, you can send it a message like the one shown below.
This will cause the player to disconnect from its side.

.Connection teardown message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x0100)
----

Note that this uses the same “magic” _TxID_ value, `fffffffe`, that is
used by the query context setup message.

[[experimenting-with-metadata]]
== Experimenting with Metadata

The best way to get a feel for the details of working with these
messages is to load dysentery into a Clojure REPL, as described on the
https://github.com/Deep-Symmetry/dysentery#dysentery[project page],
and play with some of the functions in the `dysentery.dbserver`
namespace. Have no more than three players connected and active on
your network, so you have an unused player number for dysentery to
use. In this example, player number 1 is available, so we set
dysentery up to pose as player 1 (user input is shown in bold):

[subs="quotes"]
----
> *lein repl*
nREPL server started on port 53806 on host 127.0.0.1 -
 nrepl://127.0.0.1:53806
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_77-b03
dysentery loaded.

dysentery.core> *(view/watch-devices :player-number 1)*
Looking for DJ Link devices...
Found:
   DJM-2000nexus 33 /172.16.42.3
   CDJ-2000nexus 2 /172.16.42.4
To communicate create a virtual CDJ with address
  /172.16.42.2, MAC address 3c:15:c2:e7:08:6c,
  and use broadcast address /172.16.42.255
:socket \#object[java.net.DatagramSocket 0x22b952b1
                 "java.net.DatagramSocket@22b952b1"],
:watcher #future[:status :pending, :val nil 0x3eb8f41b]

dysentery.core> *(def p2 (db/connect-to-player 2 1))*
Transaction: 4294967294, message type: 0x4000
 (requested data available), argument count: 2, arguments:
  number:          0 (0x00000000) [request type]
  number:          2 (0x00000002) [# items available]
\#'dysentery.core/p2

dysentery.core> *(def md (db/request-metadata p2 2 1))*
Sending > Transaction: 1, message type: 0x2002
 (request track metadata), argument count: 2, arguments:
  number:   16843265 (0x01010201) [player, menu, media, 1]
  number:          1 (0x00000001) [rekordbox ID]
Received > Transaction: 1, message type: 0x4000
 (requested data available), argument count: 2, arguments:
  number:       8194 (0x00002002) [request type]
  number:         11 (0x0000000b) [# items available]
      Sending > Transaction: 2, message type: 0x3000
       (render menu), argument count: 6, arguments:
  number: 16843265 (0x01010201) [player, menu, media, 1]
  number:        0 (0x00000000) [offset]
  number:       11 (0x0000000b) [limit]
  number:        0 (0x00000000) [unknown (0)?]
  number:       11 (0x0000000b) [len_a (= limit)?]
  number:        0 (0x00000000) [unknown (0)?]
Received 1  > Transaction: 2, message type: 0x4001
 (rendered menu header), argument count: 2, arguments:
  number:          1 (0x00000001) [unknown]
  number:          0 (0x00000000) [unknown]
Received 2  > Transaction: 2, message type: 0x4101
 (rendered menu item), argument count: 12, arguments:
  number:        1 (0x00000001) [numeric 1 (parent id)]
  number:        1 (0x00000001) [numeric 2 (this id)]
  number:       80 (0x00000050) [label 1 byte size]
  string: "Escape ft. Zoë Phillips" [label 1]
  number:        2 (0x00000002) [label 2 byte size]
  string: "" [label 2]
  number:        4 (0x00000004) [item type: Track Title]
  number: 16777216 (0x01000000) [column configuration?]
  number:        0 (0x00000000) [album art id]
  number:        0 (0x00000000) [playlist position]
  number:      256 (0x00000100) [unknown]
  number:        0 (0x00000000) [unknown]
...

Received 13  > Transaction: 2, message type: 0x4201
 (rendered menu footer), argument count: 0, arguments:
#'dysentery.core/md
dysentery.core>
----

In this interaction, after setting up the watcher so we can find
players on the network, we set the `var` `p2` to be a connection to
player 2, in which we are posing as player 1. Then we submit a
metadata request to `p2`, requesting the track in slot 2 (SD card),
with _rekordbox_ id 1. You can see the messages being sent and
received to accomplish that. For more functions that you can call,
including the very flexible `experiment` function, look at the source
for the `dysentery.dbserver` namespace. Most of the response messages
containing track metadata were omitted for brevity; you will get more
meaningful results trying it with your own tracks, and then you can
see all the details.
