= Track Metadata
James Elliott <james@deepsymmetry.org>
:icons: font
:experimental:

Thanks to https://github.com/EvanPurkhiser[@EvanPurkhiser], we finally
started making progress in retrieving metadata from CDJs, and then
some shared code from https://bitbucket.org/awwright/libpdjl[Austin
Wright] boosted our understanding considerably, and led to this
section.

== Connecting to the Database

The first step is to determine the port on which the player is
offering its remote database server. That can be determined by opening
a TCP connection to port 12523 on the player and sending it sending
a packet with the following content:

.DB Server query packet.
[bytefield]
----
(draw-column-headers)
(draw-related-boxes (concat [0 0 0 0x0f]
                            (map #(text % :hex) "RemoteDBServer")
                            [0]))
----

The player will send back a two-byte response, containing the high
byte of the port number followed by the low byte. So far, the response
from a CDJ has always indicated a port number of 1051, but using this
query to determine the port to use will protect you against any future
changes. The same query can also be sent to a laptop running rekordbox
to find the rekordbox database server port, which can also be queried
for metadata in the exact same way described below.

To find the metadata associated with a particular track, given its
rekordbox ID number, as well as the player and slot from which it was
loaded (all of which can be determined from a CDJ status packet
received by a virtual CDJ as described in
<<vcdj#creating-vcdj,Creating a Virtual CDJ>>), open a TCP connection
to the device from which the track was loaded, using the port that it
gave you in response to the DB Server query packet, then send the
following four packets. (You can also get metadata for non-rekordbox
tracks, even for CD Audio tracks being played in the CD slot, using
the variation described in TODO: _Section 6.6_.)

Once you have determined the database port, send it a setup packet
with the following content, and the server will send the same five
bytes back:

.Database connection setup packet.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field 1)
----

All further packets have a shared structure. They consist of lists of
type-tagged fields (a type byte, followed some number of value bytes,
although in the case of the variable-size types, the first four bytes
are a big-endian integer that specifies the length of the additional
value bytes that make up the field). So far, there are four known
field types, and it turns out that the packet we just saw is one of
them, it represents the number 1 as a 4-byte integer.

== Field Types

The first byte of a field identifies what type of field is coming. The
values `0f`, `10`, and `11` are followed by `1`, `2`, and `4` byte
fixed-length integer fields, while `14` and `26` introduce
variable-length fields, a binary blob and a UTF-16 big-endian string
respectively.

=== Number Fields

Number fields are indicated by an initial byte{nbsp}``0f``, `10`, or
`11` which is followed by big-endian integer value of length `1`, `2`,
or `4` bytes respectively, as shown below. So, as noted above, the
initial greeting packet sent to and received back from the database
server is a number field, four bytes long, representing the value 1.

.Number Field of length 1.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 2)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 1)
----

.Number Field of length 2.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 3)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 2)
----

.Number Field of length 4.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math))
----

=== Binary Fields

Variable-length binary (blob) fields are indicated by an initial
byte{nbsp}``14``, followed by a `4` byte big-endian integer which
specifies the length of the field payload. This length is followed by
the specified number of bytes (for example, an album art image,
waveform or beat grid):

.Binary (Blob) Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-binary-field "Binary Data")
(draw-bottom)
----

=== String Fields

Variable-length string fields are indicated by an initial
byte{nbsp}``26``, followed by a `4` byte big-endian integer which
specifies the length of the string, in two-byte UTF-16 big-endian
characters. So the length is folowed by 2 × _length_ bytes containing
the actual string characters. The last character of the string is
always `NUL`, represented by `0000`:

.String Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-string-field "UTF-16BE string")
(draw-bottom)
----

== Messages

Messages are introduced by a 4{nbsp}byte Number field containing a
“magic“ value (it is always `872349ae`). This is followed by another
4{nbsp}byte number field that contains a transaction ID (_TxID_),
which starts at 1 and is incremented for each query sent, and all
messages sent in response to that query will contain the same
transaction ID. This is followed by a 2{nbsp}byte number field
containing the message _type_, a 1{nbsp}byte number field (_n_)
containing the number of argument fields present in the message, and a
blob field containing a series of bytes which identify the types of
each argument field (shown as _t~1~_ through _t~12~_ below). This blob
is always twelve bytes long, regardless of how few arguments there are
(and presumably this means no message ever has more than twelve
arguments). Tag bytes past the actual argument count of the message
are set to 0.

This header is followed by the fields that make up the message
arguments, if any. In other words, the message body consists of
arguments identified by the header.

.Message structure showing header fields.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-number-field 0x872349ae 4 :bg-green)
(draw-number-field (text "TxID" :math) 4 :bg-yellow)
(draw-number-field (text "type" :math) 2 :bg-pink)
(draw-number-field (text "n" :math) 1 :bg-cyan)
(draw-box 0x14 [:bg-purple {:borders {:left   :border-unrelated
                                      :top    :border-unrelated
                                      :right  :border-related
                                      :bottom :border-related}}])

(draw-box (text "0000000c" :hex [[:plain {:font-weight "light" :font-size 16}] " (12)"])
          [{:span 4} [:bg-purple {:borders {:left   :border-related
                                            :top    :border-unrelated
                                            :right  :border-related
                                            :bottom :border-unrelated}}]])
(doseq [i (map inc (range 11))]
  (draw-box (text "t" :math [:sub i]) [:box-related :bg-purple]))
(draw-box (text "t" :math [:sub 12]) [:bg-purple {:borders {:left   :border-related
                                                  :top    :border-related
                                                  :right  :border-unrelated
                                                  :bottom :border-unrelated}}])
(draw-gap "Arguments")
(draw-bottom)
----

The argument type tags use different values than the field type tags
themselves, for some reason, and it is not clear why this redundant
information is necessary at all—but that is true a number of places in
the protocol as we have seen before and will see again. Here are the
known tag values and their meanings:

[[message-argument-tag-values]]
.Argument tag values.
[cols=">1m,<15"]
|===
|Tag |Meaning

|02 |A string in UTF-16 big-endian encoding, with trailing NUL (zero) character.
|03 |A binary blob.
|06 |A 4 byte big-endian integer.
|===

I am guessing that if we ever see them, a tag of `04` would represent
a 1{nbsp}byte integer, and `05` would represent a 2{nbsp}byte integer.
But so far no such messages have been seen.

Before you can send your first actual query, you need to send a
special message which seems to be necessary for establishing the
context for queries. It has a _type_ of `0000`, a special _TxID_ value
of `fffffffe`, and a single numeric argument, like this:

.Query context setup message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0 6)
(draw-number-field (text "D" :math [:sub "ours"]))
----

The value _D_ is, like in the other packets we have seen, a player
device number. In this case it is the device that is asking for
metadata information. It must be a valid player number between 1 and
4, and that player must actually be present on the network, must not
be the same player that you are contacting to request metadata from,
and must not be a player that has connected to that player via Link
and loaded a track from it. So the safest device number to use is the
device number you are using for your virtual CDJ, but since it must be
between 1 and 4, you can only do that if there are fewer than four
actual CDJs on the network.

The player will respond with a message of type `4000`, which is the
common “success” response when requested data is available. The
response message has two numeric arguments, the first of which is the
message type of the request we sent (which was `0000`), and the second
usually tells you the number of items that are available in response
to the query you made, but in this special setup query, it returns its
own player number:

.Query context setup response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header "0 response" 6 6)
(draw-number-field 0)
(draw-number-field (text "D" :math [:sub "theirs"]))
----



To be continued...

.Cue point response message.
[bytefield]
----
;; Figure 48
include::example$dbserver_shared.edn[]
include::example$cue_point_response.edn[]
----

include::partial$Footer.adoc[]
