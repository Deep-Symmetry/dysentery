= Track Metadata
James Elliott <james@deepsymmetry.org>
:icons: font
:experimental:

Thanks to https://github.com/EvanPurkhiser[@EvanPurkhiser], we finally
started making progress in retrieving metadata from CDJs, and then
some shared code from https://bitbucket.org/awwright/libpdjl[Austin
Wright] boosted our understanding considerably, and led to this
section.

== Connecting to the Database

The first step is to determine the port on which the player is
offering its remote database server. That can be determined by opening
a TCP connection to port 12523 on the player and sending it sending
a packet with the following content:

.DB Server query packet.
[bytefield]
----
(draw-column-headers)
(draw-related-boxes (concat [0 0 0 0x0f]
                            (map #(text % :hex) "RemoteDBServer")
                            [0]))
----

The player will send back a two-byte response, containing the high
byte of the port number followed by the low byte. So far, the response
from a CDJ has always indicated a port number of 1051, but using this
query to determine the port to use will protect you against any future
changes. The same query can also be sent to a laptop running rekordbox
to find the rekordbox database server port, which can also be queried
for metadata in the exact same way described below.

To find the metadata associated with a particular track, given its
rekordbox ID number, as well as the player and slot from which it was
loaded (all of which can be determined from a CDJ status packet
received by a virtual CDJ as described in
<<vcdj#creating-vcdj,Creating a Virtual CDJ>>), open a TCP connection
to the device from which the track was loaded, using the port that it
gave you in response to the DB Server query packet, then send the
following four packets. (You can also get metadata for non-rekordbox
tracks, even for CD Audio tracks being played in the CD slot, using
the variant described in <<non-rekordbox-metadata>>.)

Once you have determined the database port, send it a setup packet
with the following content, and the server will send the same five
bytes back:

.Database connection setup packet.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field 1)
----

All further packets have a shared structure. They consist of lists of
type-tagged fields (a type byte, followed some number of value bytes,
although in the case of the variable-size types, the first four bytes
are a big-endian integer that specifies the length of the additional
value bytes that make up the field). So far, there are four known
field types, and it turns out that the packet we just saw is one of
them, it represents the number 1 as a 4-byte integer.

== Field Types

The first byte of a field identifies what type of field is coming. The
values `0f`, `10`, and `11` are followed by `1`, `2`, and `4` byte
fixed-length integer fields, while `14` and `26` introduce
variable-length fields, a binary blob and a UTF-16 big-endian string
respectively.

=== Number Fields

Number fields are indicated by an initial byte{nbsp}``0f``, `10`, or
`11` which is followed by big-endian integer value of length `1`, `2`,
or `4` bytes respectively, as shown below. So, as noted above, the
initial greeting packet sent to and received back from the database
server is a number field, four bytes long, representing the value 1.

.Number Field of length 1.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 2)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 1)
----

.Number Field of length 2.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 3)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math) 2)
----

.Number Field of length 4.
[bytefield]
----
include::example$dbserver_shared.edn[]
(def boxes-per-row 5)
(def left-margin 1)
(draw-column-headers)
(draw-number-field (text "n" :math))
----

=== Binary Fields

Variable-length binary (blob) fields are indicated by an initial
byte{nbsp}``14``, followed by a `4` byte big-endian integer which
specifies the length of the field payload. This length is followed by
the specified number of bytes (for example, an album art image,
waveform or beat grid):

.Binary (Blob) Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-binary-field "Binary Data")
(draw-bottom)
----

=== String Fields

Variable-length string fields are indicated by an initial
byte{nbsp}``26``, followed by a `4` byte big-endian integer which
specifies the length of the string, in two-byte UTF-16 big-endian
characters. So the length is folowed by 2 × _length_ bytes containing
the actual string characters. The last character of the string is
always `NUL`, represented by `0000`:

.String Field.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-string-field "UTF-16BE string")
(draw-bottom)
----

[[messages]]
== Messages

Messages are introduced by a 4{nbsp}byte Number field containing a
“magic“ value (it is always `872349ae`). This is followed by another
4{nbsp}byte number field that contains a transaction ID (_TxID_),
which starts at 1 and is incremented for each query sent, and all
messages sent in response to that query will contain the same
transaction ID. This is followed by a 2{nbsp}byte number field
containing the message _type_, a 1{nbsp}byte number field (_n_)
containing the number of argument fields present in the message, and a
blob field containing a series of bytes which identify the types of
each argument field (shown as _t~1~_ through _t~12~_ below). This blob
is always twelve bytes long, regardless of how few arguments there are
(and presumably this means no message ever has more than twelve
arguments). Tag bytes past the actual argument count of the message
are set to 0.

This header is followed by the fields that make up the message
arguments, if any. In other words, the message body consists of
arguments identified by the header.

.Message structure showing header fields.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-column-headers)
(draw-number-field 0x872349ae 4 :bg-green)
(draw-number-field (text "TxID" :math) 4 :bg-yellow)
(draw-number-field (text "type" :math) 2 :bg-pink)
(draw-number-field (text "n" :math) 1 :bg-cyan)
(draw-box 0x14 [:bg-purple {:borders {:left   :border-unrelated
                                      :top    :border-unrelated
                                      :right  :border-related
                                      :bottom :border-related}}])

(draw-box (text "0000000c" :hex [[:plain {:font-weight "light" :font-size 16}] " (12)"])
          [{:span 4} [:bg-purple {:borders {:left   :border-related
                                            :top    :border-unrelated
                                            :right  :border-related
                                            :bottom :border-unrelated}}]])
(doseq [i (map inc (range 11))]
  (draw-box (text "t" :math [:sub i]) [:box-related :bg-purple]))
(draw-box (text "t" :math [:sub 12]) [:bg-purple {:borders {:left   :border-related
                                                  :top    :border-related
                                                  :right  :border-unrelated
                                                  :bottom :border-unrelated}}])
(draw-gap "Arguments")
(draw-bottom)
----

The argument type tags use different values than the field type tags
themselves, for some reason, and it is not clear why this redundant
information is necessary at all—but that is true a number of places in
the protocol as we have seen before and will see again. Here are the
known tag values and their meanings:

[[message-argument-tag-values]]
.Argument tag values.
[cols=">1m,<15"]
|===
|Tag |Meaning

|02 |A string in UTF-16 big-endian encoding, with trailing NUL (zero) character.
|03 |A binary blob.
|06 |A 4 byte big-endian integer.
|===

I am guessing that if we ever see them, a tag of `04` would represent
a 1{nbsp}byte integer, and `05` would represent a 2{nbsp}byte integer.
But so far no such messages have been seen.

Before you can send your first actual query, you need to send a
special message which seems to be necessary for establishing the
context for queries. It has a _type_ of `0000`, a special _TxID_ value
of `fffffffe`, and a single numeric argument, like this:

.Query context setup message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0 6)
(draw-number-field (text "D" :math [:sub "ours"]))
----

The value _D_ is, like in the other packets we have seen, a player
device number. In this case it is the device that is asking for
metadata information. It must be a valid player number between 1 and
4, and that player must actually be present on the network, must not
be the same player that you are contacting to request metadata from,
and must not be a player that has connected to that player via Link
and loaded a track from it. So the safest device number to use is the
device number you are using for your virtual CDJ, but since it must be
between 1 and 4, you can only do that if there are fewer than four
actual CDJs on the network.

The player will respond with a message of type `4000`, which is the
common “success” response when requested data is available. The
response message has two numeric arguments, the first of which is the
message type of the request we sent (which was `0000`), and the second
usually tells you the number of items that are available in response
to the query you made, but in this special setup query, it returns its
own player number:

[[query-context-setup-response]]
.Query context setup response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header "0 response" 6 6)
(draw-number-field 0)
(draw-number-field (text "D" :math [:sub "theirs"]))
----

[[track-metadata]]
== Rekordbox Track Metadata

To ask for metadata about a particular rekordbox track, send a packet
like this:

[[track-metadata-request-message]]
.Rekordbox track metadata request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2002 6 6)
(draw-dmst-field 1)
(draw-number-field (text "rekordbox" :math))
----

As described above, _TxID_ should be 1 for the first query packet you
send, 2 for the next, and so on.

The first argument of this message requires a little explanation: it
is sent as a four-byte number field, but each byte has a separate
meaning. _D_ should have the same value you used in your initial query
context setup packet, identifying the device that is asking the
question. The second byte is referred to as _M_, and seems to identify
the particular menu location on the CDJ where results are going to be
displayed. For this kind of metadata request it always has the value
`01`.

_S~r~_ is the slot in which the track being asked about can be found,
and has the same values used in CDJ status packets, as described in
the <<vcdj#slot-identifiers,CDJ status packet description>>.
Similarly, _T~r~_ identifies the type of track we want information
about; for rekordbox tracks this always has the value `01`.

This first argument format is used for many different requests about
tracks, so it is given the acronym _DMST_ in future discussion.

The second message argument, _rekordbox_, identifies the local
rekordbox database ID of the track being asked about, as found in the
<<vcdj#cdj-status-packet,CDJ status packet>>.

As suggested in the above description, track metadata requests are
built on the mechanism that is used to request and draw scrollable
menus on the CDJs, so the request is essentially interpreted as
setting up to draw the “menu” of information that is known about the
track. The player responds with a success indicator, saying it is
ready to send these “menu items” and reporting how many of them are
available:

.Track metadata available response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4000 6 6)
(draw-number-field 0x2002)
(draw-number-field 0xb)
----

We’ve seen this type of “data available” response already in the
<<query-context-setup-response,query context setup response>>, but
this one is a more typical example. As usual, _TxID_ matches the value
we sent in our request, and the first argument, with value `2002`,
reflects the _type_ field of our request. The second argument reports
that there are 11 (`0b`) entries of track metadata available to be
retrieved for the track we asked about, and that the player is ready
to send them to us.

If there was no track with ID _rekordbox_ in that media slot, the
second argument would have the value `ffffffff` to let us know. If we
messed up something else about the request, we will get a response
with a _type_ other than `4000`. See TODO: Section 6.16 for
instructions on how to explore these variations on your own.

But assuming everything went well, we can get the player to send us
all eleven of those metadata entries by telling it to render all of
the current menu, using a “render menu” request with _type_ `3000`
like this:

.Render Menu request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x3000 6 6 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field (text "offset" :math))
(draw-number-field (text "limit" :math))
(draw-number-field 0)
(draw-number-field (text "total" :math))
(draw-number-field 0)
----

As always, the value of _TxID_ should be one higher than the one you
sent in your setup packet, while the values of _D_, _S~r~_, and _T~r~_
should be identical to what you sent in it.

The request has six numeric arguments. At this point it is worth
talking a bit more about the byte after _D_ in the first argument.
This seems to specify the location of the menu being drawn, with the
value 1 meaning the main menu on the left-hand half of the CDJ
display, while 2 means the submenu (for example the info popup when it
is open) which overlays the right-hand half of the display. We don’t
yet know exactly what, if any, difference there is between the
response details when 2 is used instead of 1 here. And special data
requests use different values: for example, the track waveform
summary, which is drawn in a strip along the entire bottom of the
display, is requested with a menu location number of 8 in this second
byte.

As described above, _T~r~_ has the value 1 for rekordbox tracks.

The second argument, _offset_, specifies which menu entry is the first
one you want to see, and the third argument, _limit_, specifies how
many should be sent. In this case, since there are only 11 entries, we
can request them all at once, so we will set _offset_ to 0 and _limit_
to 11. But for large playlists, for example, you need to request
batches of entries that are smaller than the total available, or the
player will be unable to send them to you. We have not found what the
exact limit is, but getting 64 at a time seems to work on Nexus 2
players.

We don’t know the purpose of the fourth argument, but sending a value
of 0 works. The fifth argument, _total_, seems to usually contain the
total number of items reported in the intial menu response, but
sending a second copy of _limit_ here works too; it may not matter much.
And the sixth and final argument also has an unknown purpose, but 0
works.

So, for our metadata request, the packet we want to send in order to
get all the metadata will have the specific values shown here:

.Render track metadata request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x3000 6 6 6 6 6 6)
(draw-dmst-field 1)
(draw-number-field 0)
(draw-number-field 0xb)
(draw-number-field 0)
(draw-number-field 0xb)
(draw-number-field 0)
----

This causes the player to send us 13 messages: The 11 metadata items
we requested are sent (with _type_ `4101`, <<menu-item-response,second
figure below>>), but they are preceded by a menu header message (with
_type_ `4001`, <<menu-header-response,first figure below>>), and
followed by a menu footer message (with _type_ `4201`,
<<menu-footer-response,third figure below>>). This wrapping happens
with all “render menu” requests, and the menu footer is an easy way to
know you are done, although you can also count the messages.

[[menu-header-response]]
.Menu header response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4001 6 6)
(draw-number-field 1)
(draw-number-field 0)
----

The menu item responses all have the same structure, and use all
twelve message argument slots, containing ten numbers and two strings,
although they generally don’t have meaningful values in all of the
slots. They have the general structure shown here, and the arguments
are listed in the Table <<menu-item-arguments,below>>:

[[menu-item-response]]
.Menu item response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4101 6 6 6 2 6 2 6 6 6 6 6 6)
(draw-gap "Arguments")
(draw-bottom)
----

[[menu-footer-response]]
.Menu footer response.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4201)
----

[[menu-item-arguments]]
.Menu item arguments.
[cols=">1,^3,<12"]
|===
|Arg |Type |Meaning

|1 |number |Parent ID, such as an artist for a track item.
|2 |number |Main ID, such as _rekordbox_ for a track item.
|3 |number |Length in bytes of Label 1.
|4 |string |Label 1 (main text, such as the track title or artist name, as appropriate for the item type).
|5 |number |Length in bytes of Label 2.
|6 |string |Label 2 (secondary text, e.g. artist name for playlist entries, where Label 1 holds the title).
|7 |number |Type of this item (see <<menu-item-types>>).
|8 |number |Some sort of flags field, details still unclear.
|9 |number |Holds _artwork_ ID when type is Track Title.
|10 |number |Playlist position when relevant, e.g. when listing a playlist.
|11 |number |Unknown.
|12 |number |Unknown.
|===

[[track-metadata-title]]
=== Track Metadata Item 1: Title

The first item returned after the menu header is the track title, so
argument 7 has the value `04`. Argument 1, which may always be some
kind of parent ID, holds the artist ID associated with the track. The
second argument seems to always be the main ID, and for this response
it holds the _rekordbox_ ID of the track. Argument 4 holds the track
title text, and argument 9 holds the album _artwork_ ID if any is
available for the track. This ID can be used to retrieve the actual
album art image as described in <<album-art>>.

=== Track Metadata Item 2: Artist

The second item contains artist information, so argument 7 has the
value `07`. Argument 2 holds the artist ID, and argument 4 contains
the text of the artist name.

=== Track Metadata Item 3: Album Title

The third item contains album title information, so argument 7 has the
value `02`. Argument 4 contains the text of the album name.

=== Track Metadata Item 4: Duration

The fourth item contains track duration information, so argument 7 has
the value `0b`. Argument 2 contains the length, in seconds, of the
track when played at normal tempo.

=== Track Metadata Item 5: Tempo

The fifth item contains tempo information, so argument 7 has the value
`0d`. Argument 2 contains the track’s starting tempo, in beats per
minute, times 100, as reported in _BPM_ values in other packets
described earlier.

=== Track Metadata Item 6: Comment

The sixth item contains comment information, so argument 7 has the
value `23`. Argument 4 contains the text of the track comment entered
by the DJ in rekordbox.

=== Track Metadata Item 7: Key

The seventh item contains key information, so argument 7 has the value
`0f`. Argument 4 contains the text of the track’s dominant key
signature.

=== Track Metadata Item 8: Rating

The eighth item contains rating information, so argument 7 has the
value `0a`. Argument 2 contains a value from 0 to 5 corresponding to
the number of stars the DJ has assigned the track in rekordbox.

=== Track Metadata Item 9: Color

The ninth item contains color information, so argument 7 has a value
between `13` and `1b` identifying the color, if any, assigned to the
track (see <<menu-item-types-colors,Menu Item Types>> for the color
choices), and if the value is anything other than `13`, Argument 4
contains the text that the DJ has assigned for that color meaning in
rekordbox.

=== Track Metadata Item 10: Genre

The tenth item contains genre information, so argument 7 has the value
`06`. Argument 2 contains the numeric genre ID, and argument 4
contains the text of the genre name.

=== Track Metadata Item 11: Date Added

The eleventh and final item contains information about the the date
the track was added to the collection, so argument 7 has the value
`2e`. Argument 4 contains the date the track was added to the
collection in the format “yyyy-mm-dd”. This information seems to
propagate into rekordbox from iTunes.

== Menu Footer Response

The menu footer message has a _type_ of `4201` and no arguments, so it
has a header only, and is always made up of the
<<menu-footer-response,exact same sequence of bytes>> (apart from the
_TxID_).

[[menu-item-types]]
== Menu Item Types

As noted above, the seventh argument in a menu item response
identifies the type of the item. The meanings we have identified so
far are:

.Known menu item types.
[cols=">1m,<11"]
|===
|Type |Meaning

|0001 |Folder (such as in the playlists menu)footnote:[A nested list of playlists rather than an individual playlist.]
|0002 |Album title
|0003 |Disc
|0004 |Track Title
|0006 |Genre
|0007 |Artist
|0008 |Playlist
|000a |Rating
|000b |Duration (in seconds)
|000d |Tempo
|000e |Label
|000f |Key
|0010 |Bit Rate
|0011 |Year
| |
[[menu-item-types-colors]]
|0013 |Color None
|0014 |Color Pink
|0015 |Color Red
|0016 |Color Orange
|0017 |Color Yellow
|0018 |Color Green
|0019 |Color Aqua
|001a |Color Blue
|001b |Color Purple
| |
|0023 |Comment
|0024 |History Playlist
|0028 |Original Artist
|0029 |Remixer
|002e |Date Added
| |
|0080 | Genre menu
|0081 | Artist menu
|0082 | Album menu
|0083 | Track menu
|0084 | Playlist menu
|0085 | BPM menu
|0086 | Rating menu
|0087 | Year menu
|0088 | Remixer menu
|0089 | Label menu
|008a | Original Artist menu
|008b | Key menu
|008e | Color menu
|0090 | Folder menu
|0091 | Search “menu”
|0092 | Time menu
|0093 | Bit Rate menu
|0094 | Filename menu
|0095 | History menu
|00a0 | All
| |
|0204 | Track Title and Album
|0604 | Track Title and Genre
|0704 | Track Title and Artist
|0a04 | Track Title and Rating
|0b04 | Track Title and Time
|0d04 | Track Title and BPM
|0e04 | Track Title and Label
|0f04 | Track Title and Key
|1004 | Track Title and Bit Rate
|1a04 | Track Title and Bit Color
|2304 | Track Title and Comment
|2804 | Track Title and Original Artist
|2904 | Track Title and Remixer
|2a04 | Track Title and DJ Play Count
|2e04 | Track Title and Date Added
|===

As noted above, track metadata responses use many of these types.
Others are used in different kinds of menus and queries.

[[non-rekordbox-metadata]]
== Non-Rekordbox Track Metadata

As discussed in the introduction to this section, you can get metadata
for non-rekordbox tracks as well (although they don’t have beat grids,
waveforms, or album art available). All you need to do is use a slight
variant of the <<track-metadata-request-message,metadata request
message>>, using the value `2202` (instead of `2002`) for the message
type, and a value of _T~r~_ that is appropriate for the kind of track
you are asking about (`02` for non-rekordbox tracks loaded from media
slots, and `05` for CD audio tracks playing in the CD slot, which has
a _S~r~_ value of `01`). After the initial query setup message, the
other message types are the same as in the above discussion, but you
will continue using the _S~r~_ and _T~r~_ values appropriate for the
slot and media type you are asking about.

Since these tracks don’t have rekordbox IDs, you will need to use the
_rekordbox_ value reported in CDJ status packets in order to find out
the values used to request the metadata for tracks loaded from solid
state media; CD tracks are requested using the simple track number
as the _rekordbox_ value.

TIP: It seems that to reliably get data back when requesting metadata
for non-rekordbox tracks, your virtual CDJ needs to be sending
properly-formatted status packets, not just device announcement
packets.

[[album-art]]
== Album Art

To request the artwork image associated with a track, send a message
with _type_ `2003` containing the _artwork_ ID that was specified in
the track title item (as described in <<track-metadata-title>>), like
this:

.Track artwork request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2003 6 6)
(draw-dmst-field 8)
(draw-number-field (text "artwork" :math))
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj#cdj-status-packet,CDJ status packets>>. Finally, _artwork_
identifies the specific artwork image you are requesting, as it was
specified in the track medatata response. As with other graphical
requests, the value after _D_, which identifies the location of the
menu for which data is being loaded, is 8.

The response will be a message with _type_ `4002`, containing four
arguments. The first argument echoes back our request type, which was
`2003`. The second always seems to be 0. The third contains the length
of the image in bytes, which seems redundant, because that is also
conveyed in the fourth argument itself, a blob containing the actual
bytes of the image data, as shown below. However, if there is no image
data, this value will be 0, and the blob field will be completely
omitted from the response, so you _must not_ try to read it!

.Track artwork response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4002 6 6 6 3)
(draw-number-field 0x2003)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Image bytes" {:length-label (text "length" :math)})
(draw-bottom)
----

To experiment with this, start up dysentery in a Clojure REPL and
connect to a player as described in TODO: Section 6.16, then evaluate
an expression like:

[source,clojure]
----
(def art (db/request-album-art p2 3 3))
----

Replace the arguments with the `var` holding your player connection,
the proper _S~r~_ number for the media slot holding the art, and the
_artwork_ ID of the album art, and dysentery will open a window like
this showing the image:

image::Album-art-example.png[alt=Album Art,width=213,height=152]

To load artwork for a non-rekordbox track, add an additional argument
with the value 2 at the end.

== Beat Grids

The CDJs do not send any timing information other than beat numbers
during playback, which has made it difficult to offer absolute
timecode information. The discovery of beat grid requests provides a
clean answer to the problem. The beat grid for a track is a list of
every beat which occurs in the track, along with the point in time at
which that beat would occur if the track were played at its standard
(100%) tempo. Armed with this table, it is possible to translate any
beat packet into an absolute position within the track, and, combined
with the tempo information, to generate timecode signals allowing
other software (such as video resources) to sync tightly with DJ
playback.

To request the beat grid of a track, send a message with _type_ `2204`
containing the _rekordbox_ ID of the track:

.Track beat grid request message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x2204 6 6)
(draw-dmst-field 8)
(draw-number-field (text "rekordbox" :math))
----

As usual, _TxID_ should be incremented each time you send a query, and
will be used to identify the response messages. _D_ should have the
same value you used in your initial query context setup packet,
identifying the device that is asking the question. _S~r~_ and _T~r~_
are the slot in which the track being asked about can be found and its
track type; each has the same values used in
<<vcdj#cdj-status-packet,CDJ status packets>>. Finally, _rekordbox_
identifies the specific beat grid you are requesting, as found in a
CDJ status packet or playlist response. As with graphical requests,
the value after 𝐷, which identifies the location of the menu for which
data is being loaded, is 8.

The response will be a message with _type_ `4602`, containing four
arguments. The first argument echoes back our request type, which was
`2204`. The second always seems to be 0. The third contains the length
of the beat grid in bytes, which seems redundant, because that is also
conveyed in the fourth argument itself, which is a blob containing the
actual bytes of the beat grid, as shown below. However, if there is no
beat grid available, this value will be 0, and the blob field will be
completely omitted from the response, so you _must not_ try to read it!

.Track beat grid response message.
[bytefield]
----
include::example$dbserver_shared.edn[]
(draw-remotedb-header 0x4602 6 6 6 3)
(draw-number-field 0x2204)
(draw-number-field 0)
(draw-number-field (text "length" :math))
(draw-binary-field "Beat grid bytes" {:length-label (text "length" :math)})
(draw-bottom)
----

The beat grid itself is spread through the value returned as argument
4, consisting of one-byte beat-within-bar numbers (labeled _B~b~_ in
the <<vcdj#cdj-status-packet,CDJ status packet diagram>>), followed by
four-byte timing information, specifying the number of milliseconds
after the start of the track (when played at its native tempo) at
which that beat falls.

The _B~b~_ value of the first beat in the track is found at byte
`0x14` of argument 4, and the time at which that beat occurs, in
milliseconds, is encoded as a 4-byte
little-endian{empty}footnote:[Yes, unlike almost all numbers in the
protocol, beat grid and cue point times are little-endian.] integer at
bytes{nbsp}``15``–`18`. Subsequent beats are found at `0x10`-byte
intervals, so the second _B~b~_ value is found at byte{nbsp}``24``,
and the second beat’s time, in milliseconds from the start of the
track, is the big-endian integer at bytes{nbsp}``25``–`28`. The _B~b~_
value for the third beat is at byte{nbsp}``34``, and its millisecond
time is at bytes{nbsp}``35``–`38`, and so on.

The purpose of the other bytes within the beat grid is so far
undetermined. It looks like there may be some sort of monotonically
increasing value following the beat millisecond value, but what it
means, and why it sometimes skips values, is mysterious.


To be continued...

.Cue point response message.
[bytefield]
----
;; Figure 48
include::example$dbserver_shared.edn[]
include::example$cue_point_response.edn[]
----

include::partial$Footer.adoc[]
